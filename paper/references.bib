
@misc{donenfeld_performance_2018,
	title = {Performance - {WireGuard}},
	url = {https://www.wireguard.com/performance/},
	language = {en},
	urldate = {2022-06-16},
	author = {Donenfeld, Jason A.},
	year = {2018},
	keywords = {speed},
}

@misc{yubico_yubikey_2022,
	title = {{YubiKey} {Bio} {Series} - {FIDO} {Edition}},
	url = {https://www.yubico.com/products/yubikey-bio-series/},
	abstract = {The YubiKey Bio Series is a FIDO-only lineup of security keys that prevent account takeovers by combining Yubico's hallmark security with the convenience of biometric login, using two-factor or passwordless multi-factor authentication.},
	language = {en-US},
	urldate = {2022-04-05},
	journal = {Yubico},
	author = {Yubico},
	month = apr,
	year = {2022},
	keywords = {biometric},
}

@misc{quapka_go-analysis_2019,
	title = {go-analysis},
	url = {https://github.com/quapka/go-analysis/blob/8457df971223e46cd8cee9f1af15291d798b763a/hsm-tokens/hsm_crypto/ecdsa/ecdsa.go},
	abstract = {The goal of the repository is to analyze Go language (fork at: https://github.com/golang/go) in regards to RSA and ECC keys generation. It's part of an assignment for PV204 Security Technologies course at Faculty of Informatics in Brno (CZ, spring 2019).},
	urldate = {2022-03-28},
	author = {quapka},
	month = apr,
	year = {2019},
	note = {original-date: 2019-03-06T15:16:57Z},
	keywords = {ecdh-derive},
}

@misc{gieben_pkcs11_2022,
	title = {{PKCS}\#11},
	copyright = {BSD-3-Clause},
	url = {https://github.com/miekg/pkcs11},
	abstract = {pkcs11 wrapper for Go},
	urldate = {2022-03-23},
	author = {Gieben, Miek},
	month = mar,
	year = {2022},
	note = {original-date: 2012-09-20T13:32:28Z},
	keywords = {c, go, hsm, miegk, pkcs11, softhsm},
}

@article{sasdrich_implementing_2015,
	title = {Implementing {Curve25519} for {Side}-{Channel}--{Protected} {Elliptic} {Curve} {Cryptography}},
	volume = {9},
	issn = {1936-7406},
	url = {http://doi.org/10.1145/2700834},
	doi = {10.1145/2700834},
	abstract = {For security-critical embedded applications Elliptic Curve Cryptography (ECC) has become the predominant cryptographic system for efficient key agreement and digital signatures. However, ECC still involves complex modular arithmetic that is a particular burden for small processors. In this context, Bernstein proposed the highly efficient ECC instance Curve25519 that particularly enables efficient software implementations at a security level comparable to AES-128 with inherent resistance to simple power analysis (SPA) and timing attacks. In this work, we show that Curve25519 is likewise competitive on FPGAs even when countermeasures to thwart side-channel power analysis are included. Our basic multicore DSP-based architectures achieves a maximal performance of more than 32,000 point multiplications per second on a Xilinx Zynq 7020 FPGA. Including a mix of side-channel countermeasures to impede simple and differential power analysis, we still achieve more than 27,500 point multiplications per second with a moderate increase in logic resources.},
	number = {1},
	urldate = {2022-03-20},
	journal = {ACM Transactions on Reconfigurable Technology and Systems},
	author = {Sasdrich, Pascal and Güneysu, Tim},
	month = nov,
	year = {2015},
	keywords = {Curve25519, Diffie-Hellman, ECC, Side-Channel Attacks, Zynq, sidechannel},
	pages = {3:1--3:15},
}

@misc{noauthor_safecurves_2022,
	title = {{SafeCurves}: {Introduction}},
	url = {https://safecurves.cr.yp.to/},
	language = {English},
	urldate = {2022-03-19},
	journal = {SafeCurves: choosing safe curves for elliptic-curve cryptography},
	month = mar,
	year = {2022},
	keywords = {safe},
}

@inproceedings{lipp_mechanised_2019,
	title = {A {Mechanised} {Cryptographic} {Proof} of the {WireGuard} {Virtual} {Private} {Network} {Protocol}},
	doi = {10.1109/EuroSP.2019.00026},
	abstract = {WireGuard is a free and open source Virtual Private Network (VPN) that aims to replace IPsec and OpenVPN. It is based on a new cryptographic protocol derived from the Noise Protocol Framework. This paper presents the first mechanised cryptographic proof of the protocol underlying WireGuard, using the CryptoVerif proof assistant. We analyse the entire WireGuard protocol as it is, including transport data messages, in an ACCE-style model. We contribute proofs for correctness, message secrecy, forward secrecy, mutual authentication, session uniqueness, and resistance against key compromise impersonation, identity mis-binding, and replay attacks. We also discuss the strength of the identity hiding provided by WireGuard. Our work also provides novel theoretical contributions that are reusable beyond WireGuard. First, we extend CryptoVerif to account for the absence of public key validation in popular Diffie-Hellman groups like Curve25519, which is used in many modern protocols including WireGuard. To our knowledge, this is the first mechanised cryptographic proof for any protocol employing such a precise model. Second, we prove several indifferentiability lemmas that are useful to simplify the proofs for sequences of key derivations.},
	booktitle = {2019 {IEEE} {European} {Symposium} on {Security} and {Privacy} ({EuroS} {P})},
	author = {Lipp, Benjamin and Blanchet, Bruno and Bhargavan, Karthikeyan},
	month = jun,
	year = {2019},
	keywords = {Elliptic curve cryptography, Protocols, Standards, VPN, Virtual private networks, computational model, security protocols, verification},
	pages = {231--246},
}

@inproceedings{hulsing_post-quantum_2021,
	title = {Post-quantum {WireGuard}},
	doi = {10.1109/SP40001.2021.00030},
	abstract = {In this paper we present PQ-WireGuard, a post-quantum variant of the handshake in the WireGuard VPN protocol (NDSS 2017). Unlike most previous work on post-quantum security for real-world protocols, this variant does not only consider post-quantum confidentiality (or forward secrecy) but also post-quantum authentication. To achieve this, we replace the Diffie-Hellman-based handshake by a more generic approach only using key-encapsulation mechanisms (KEMs). We establish security of PQ-WireGuard, adapting the security proofs for WireGuard in the symbolic model and in the standard model to our construction. We then instantiate this generic construction with concrete post-quantum secure KEMs, which we carefully select to achieve high security and speed. We demonstrate competitiveness of PQ-WireGuard presenting extensive bench-marking results comparing to widely deployed VPN solutions.},
	booktitle = {2021 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Hülsing, Andreas and Ning, Kai-Chun and Schwabe, Peter and Weber, Florian and Zimmermann, Philip R.},
	month = may,
	year = {2021},
	note = {ISSN: 2375-1207},
	keywords = {Adaptation models, Authentication, Privacy, Protocols, Security, Standards, Virtual private networks},
	pages = {304--321},
}

@inproceedings{wu_sewg_2020,
	title = {{SeWG}: {Security}-{Enhanced} {WireGuard} for {Android} {Based} on {TEE}},
	shorttitle = {{SeWG}},
	doi = {10.1109/TrustCom50675.2020.00235},
	abstract = {WireGuard, a novel VPN proposed in 2017, has been widely accepted in the industry, since it is simpler, leaner and more efficient than traditional VPNs. However, WireGuard ignores the risks of key stolen and abused on both desktop and mobile platform. These vulnerabilities might be utilized by attackers to sneak into the protected network through VPN tunnel provided by WireGuard easily without permission. It is especially obvious on mobile platforms, since they are mostly online all day and the attack scenarios are more complicated and changeable. In this paper, we propose an enhanced WireGuard Android version called SeWG based on TEE. We use TEE (Trusted Execution Environment) technology to achieve secure key storage, preventing the misuse of the private key. And we design corresponding dynamic authentication mechanisms for user mode and kernel mode respectively, to prevent malware from sneaking into the secure tunnel. Finally, we implement SeWg scheme on QSEE, the TEE platform developed by Qualcomm. Our experimental results demonstrate that SeWG can work well with high efficiency.},
	booktitle = {2020 {IEEE} 19th {International} {Conference} on {Trust}, {Security} and {Privacy} in {Computing} and {Communications} ({TrustCom})},
	author = {Wu, Yongkang and Shan, Yiwei and Wang, Zhichao and Zhang, Pengcheng and He, Min and Liu, Jihong},
	month = dec,
	year = {2020},
	note = {ISSN: 2324-9013},
	keywords = {Authorization, Industries, Kernel, Malware, Privacy, Secure storage, VPN, WireGuard, Key protection, Authorization, Mobile security, Trusted execution environment, Virtual private networks},
	pages = {1711--1717},
}

@article{hulsing_post-quantum_2021-1,
	title = {Post-quantum {WireGuard}},
	issn = {1081-6011},
	language = {eng},
	journal = {Proceedings - IEEE Symposium on Security and Privacy},
	author = {Hülsing, A. and Ning, K.-C. and Schwabe, P. and Weber, F. and Zimmermann, P. R.},
	year = {2021},
	pages = {511--528},
}

@article{omotosho_threat_2019,
	title = {Threat {Modeling} of {Internet} of {Things} {Health} {Devices}},
	volume = {14},
	issn = {1936-1610},
	doi = {10.1080/19361610.2019.1545278},
	abstract = {For a number of health conditions, the number of Internet of Things (IoT) devices available for self and remote monitoring are growing rapidly, and users are also increasing. In the same vein, cyber criminals are putting lots of effort into making these devices unsafe for users, and this has generated growing privacy concerns for both users and manufacturers. In this article, a threat model is designed for selected IoT health devices. Based on the device assets and access points, device threats were identified using the STRIDE model and ranked using a threat-risk ranking model called DREAD. Some countermeasures to mitigate each of the identified threats in the selected devices were also proposed. A Web system that presents the model was created and enables the users of devices, manufacturers, and professionals to view possible threats and severity based on the devices' risk scores. This model will benefit both the designers and users of health IoT devices in improving products' security and understanding devices' privacy risk, respectively.},
	language = {eng},
	number = {1},
	journal = {Journal of applied security research},
	author = {Omotosho, Adebayo and Ayemlo Haruna, Benjamin and Mikail Olaniyi, Olayemi},
	year = {2019},
	note = {Publisher: Routledge},
	keywords = {DREAD, Internet of Things, STRIDE, health, modeling, threat},
	pages = {106--121},
}

@misc{donenfeld_protocol_2018,
	title = {Protocol \& {Cryptography} - {WireGuard}},
	url = {https://www.wireguard.com/protocol/},
	language = {en},
	urldate = {2021-07-06},
	author = {Donenfeld, Jason A.},
	year = {2018},
}

@misc{perrin_noise_2017,
	title = {The {Noise} {Protocol} {Framework}},
	url = {http://noiseprotocol.org/noise.html},
	language = {English},
	urldate = {2022-03-13},
	author = {Perrin, Trevor},
	year = {2017},
}

@article{donenfeld_formal_2018,
	title = {Formal {Verification} of the {WireGuard} {Protocol}},
	url = {https://www.wireguard.com/papers/wireguard-formal-verification.pdf},
	abstract = {WireGuard, the secure network tunnel, uses an interesting DiﬃeHellman authenticated key exchange protocol based on NoiseIK, custom tailored to suit its unique operational requirements. This paper enumerates the security properties of this key exchange and then explores the formal veriﬁcation of such properties. The end result is a formally veriﬁed secure network tunnel protocol.},
	language = {en},
	author = {Donenfeld, Jason A and Kevin Milner},
	year = {2018},
	pages = {11},
}

@misc{noauthor_curve25519_nodate,
	title = {Curve25519: high-speed elliptic-curve cryptography},
	url = {https://cr.yp.to/ecdh.html},
	urldate = {2022-03-14},
	keywords = {curve25519},
}

@misc{noauthor_cryptsoft_nodate,
	title = {Cryptsoft},
	url = {https://www.cryptsoft.com/pkcs11doc/},
	urldate = {2022-03-14},
	keywords = {oasis, pkcs11},
}

@inproceedings{appelbaum_tiny_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Tiny wireguard tweak},
	isbn = {978-3-030-23695-3},
	doi = {10.1007/978-3-030-23696-0_1},
	abstract = {We show that a future adversary with access to a quantum computer, historic network traffic protected by WireGuard, and knowledge of a WireGuard user’s long-term static public key can likely decrypt many of the WireGuard user’s historic messages. We propose a simple, efficient alteration to the WireGuard protocol that mitigates this vulnerability, with negligible additional computational and memory costs. Our changes add zero additional bytes of data to the wire format of the WireGuard protocol. Our alteration provides transitional post-quantum security for any WireGuard user who does not publish their long-term static public key – it should be exchanged out-of-band.},
	language = {eng},
	publisher = {Springer},
	author = {Appelbaum, Jacob R. and Martindale, Chloe R. and Wu, Sinli Peter and Nitaj, Abderrahmane and Rachidi, Tajjeeddine and Buchmann, Johannes},
	year = {2019},
	note = {Book Title: Lecture notes in computer science
ISSN: 1611-3349},
	keywords = {Mass surveillance, Network protocol, Post-quantum cryptography, Privacy, Security, VPN, WireGuard, wg\_tweak},
	pages = {3--20},
}

@misc{noauthor_wireguard-tools_2022,
	title = {wireguard-tools — tools for configuring {WireGuard}},
	copyright = {GPL-2.0},
	url = {https://github.com/WireGuard/wireguard-tools},
	abstract = {Mirror only. Official repository is at https://git.zx2c4.com/wireguard-tools},
	urldate = {2022-03-13},
	publisher = {WireGuard},
	month = mar,
	year = {2022},
	note = {original-date: 2019-12-26T13:28:28Z},
	keywords = {wireguard-tools},
}

@article{he_security_2018,
	title = {Security {Analysis} of {WireGuard}},
	url = {https://courses.csail.mit.edu/6.857/2018/project/He-Xu-Xu-WireGuard.pdf},
	language = {en},
	journal = {MIT},
	author = {He, Andrew and Xu, Baula and Wu, Jerry},
	month = apr,
	year = {2018},
	pages = {11},
}

@misc{__--_----_us_2022,
	type = {Reddit {Post}},
	title = {U.{S}. intel agencies: {Russia} does not want to engage directly with {U}.{S}. military},
	shorttitle = {U.{S}. intel agencies},
	url = {www.reddit.com/r/worldnews/comments/t9k6qs/us_intel_agencies_russia_does_not_want_to_engage/},
	urldate = {2022-03-08},
	journal = {r/worldnews},
	author = {\_\_--\_----},
	month = mar,
	year = {2022},
}

@misc{noauthor_support_nodate,
	title = {Support for key exchange using {Curve25519} and {Curve448} · {Issue} \#309 · openssl/openssl},
	url = {https://github.com/openssl/openssl/issues/309},
	abstract = {Curve25519 is described in Curve25519 for ephemeral key exchange in Transport Layer Security (TLS) IETF draft. It\&\#39;s designed with speed, simplicity and security in mind, and seems to be very ni...},
	language = {en},
	urldate = {2022-03-08},
	journal = {GitHub},
	keywords = {cv25519},
}

@misc{noauthor_nitrokey_nodate,
	title = {Nitrokey {Start}},
	url = {https://shop.nitrokey.com/shop/product/nksa-nitrokey-start-6},
	language = {en-US},
	urldate = {2022-03-08},
	journal = {Nitrokey GmbH},
	keywords = {nksa},
}

@misc{noauthor_wireguard-nt_nodate,
	title = {wireguard-nt - {WireGuard} implementation for {NT} kernel},
	url = {https://git.zx2c4.com/wireguard-nt/about/},
	urldate = {2021-08-20},
}

@misc{noauthor_wireguard_nodate,
	title = {wireguard « net « drivers - wireguard-linux - {WireGuard} for the {Linux} kernel},
	url = {https://git.zx2c4.com/wireguard-linux/tree/drivers/net/wireguard/},
	urldate = {2021-07-28},
}

@misc{noauthor_things_nodate,
	title = {Things that use {Ed25519}},
	url = {https://ianix.com/pub/ed25519-deployment.html#ed25519-hardware},
	urldate = {2021-07-16},
}

@article{schwarz_practical_2019,
	title = {Practical {Enclave} {Malware} with {Intel} {SGX}},
	url = {http://arxiv.org/abs/1902.03256},
	abstract = {Modern CPU architectures offer strong isolation guarantees towards user applications in the form of enclaves. For instance, Intel's threat model for SGX assumes fully trusted enclaves, yet there is an ongoing debate on whether this threat model is realistic. In particular, it is unclear to what extent enclave malware could harm a system. In this work, we practically demonstrate the first enclave malware which fully and stealthily impersonates its host application. Together with poorly-deployed application isolation on personal computers, such malware can not only steal or encrypt documents for extortion, but also act on the user's behalf, e.g., sending phishing emails or mounting denial-of-service attacks. Our SGX-ROP attack uses new TSX-based memory-disclosure primitive and a write-anything-anywhere primitive to construct a code-reuse attack from within an enclave which is then inadvertently executed by the host application. With SGX-ROP, we bypass ASLR, stack canaries, and address sanitizer. We demonstrate that instead of protecting users from harm, SGX currently poses a security threat, facilitating so-called super-malware with ready-to-hit exploits. With our results, we seek to demystify the enclave malware threat and lay solid ground for future research on and defense against enclave malware.},
	urldate = {2021-07-07},
	journal = {arXiv:1902.03256 [cs]},
	author = {Schwarz, Michael and Weiser, Samuel and Gruss, Daniel},
	month = feb,
	year = {2019},
	note = {arXiv: 1902.03256},
	keywords = {Computer Science - Cryptography and Security},
}

@misc{noauthor_things_nodate-1,
	title = {Things that use {Curve25519}},
	url = {https://ianix.com/pub/curve25519-deployment.html},
	urldate = {2021-07-06},
}

@misc{noauthor_discover_nodate,
	title = {Discover {YubiKey} 5 {\textbar} {Strong} {Authentication} for {Secure} {Login}},
	url = {https://www.yubico.com/products/yubikey-5-overview/},
	abstract = {Check out the \#1 security key lineup that provides strong two-factor, multi-factor and passwordless authentication!},
	language = {en-US},
	urldate = {2021-07-06},
	journal = {Yubico},
}

@misc{noauthor_nitrokey_nodate-1,
	title = {Nitrokey {Start}},
	url = {https://shop.nitrokey.com/shop/product/nk-sta-nitrokey-start-6},
	language = {en-US},
	urldate = {2021-07-06},
	journal = {Nitrokey GmbH},
}

@inproceedings{wu_sewg_2020-1,
	title = {{SeWG}: {Security}-{Enhanced} {WireGuard} for {Android} {Based} on {TEE}},
	shorttitle = {{SeWG}},
	doi = {10.1109/TrustCom50675.2020.00235},
	abstract = {WireGuard, a novel VPN proposed in 2017, has been widely accepted in the industry, since it is simpler, leaner and more efficient than traditional VPNs. However, WireGuard ignores the risks of key stolen and abused on both desktop and mobile platform. These vulnerabilities might be utilized by attackers to sneak into the protected network through VPN tunnel provided by WireGuard easily without permission. It is especially obvious on mobile platforms, since they are mostly online all day and the attack scenarios are more complicated and changeable. In this paper, we propose an enhanced WireGuard Android version called SeWG based on TEE. We use TEE (Trusted Execution Environment) technology to achieve secure key storage, preventing the misuse of the private key. And we design corresponding dynamic authentication mechanisms for user mode and kernel mode respectively, to prevent malware from sneaking into the secure tunnel. Finally, we implement SeWg scheme on QSEE, the TEE platform developed by Qualcomm. Our experimental results demonstrate that SeWG can work well with high efficiency.},
	booktitle = {2020 {IEEE} 19th {International} {Conference} on {Trust}, {Security} and {Privacy} in {Computing} and {Communications} ({TrustCom})},
	author = {Wu, Yongkang and Shan, Yiwei and Wang, Zhichao and Zhang, Pengcheng and He, Min and Liu, Jihong},
	month = dec,
	year = {2020},
	note = {ISSN: 2324-9013},
	keywords = {Authorization, Industries, Kernel, Malware, Privacy, Secure storage, TEE, VPN, WireGuard, Key protection, Authorization, Mobile security, Trusted execution environment, Virtual private networks},
	pages = {1711--1717},
}

@misc{noauthor_new_2019,
	title = {The {New} {Cloudflare} {VPN}: {What} {It} {Is} \& {Isn}'t},
	shorttitle = {The {New} {Cloudflare} {VPN}},
	url = {https://openvpn.net/what-is-cloudflare-vpn/},
	abstract = {OpenVPN has been around since May 2001; that means we've gotten that much more contributions and bug fixes from our open source community. It has been through a lot of peer review, testing and validation. Wireguard is still young and developing both as a protocol and as software.},
	language = {en},
	urldate = {2021-06-09},
	journal = {OpenVPN},
	month = apr,
	year = {2019},
	keywords = {openvpn},
}

@misc{noauthor_u2f_nodate,
	title = {'{U2F} support in {OpenSSH} {HEAD}' - {MARC}},
	url = {https://marc.info/?l=openssh-unix-dev&m=157259802529972&w=2},
	urldate = {2021-06-09},
	keywords = {openssh},
}

@misc{noauthor_u2f_nodate-1,
	title = {{U2F} - {FIDO} {Universal} 2nd {Factor} authentication {\textbar} {YubiKey}},
	url = {https://www.yubico.com/authentication-standards/fido-u2f/},
	abstract = {U2F is an open authentication standard that enables internet users to securely access any number of online services with one single security key instantly and with no drivers or client software needed. FIDO2 is the latest generation of the U2F protocol.},
	language = {en-US},
	urldate = {2021-06-09},
	journal = {Yubico},
	keywords = {fido},
}

@misc{noauthor_side_nodate,
	title = {A {Side} {Journey} to {Titan}},
	url = {https://ninjalab.io/a-side-journey-to-titan/},
	abstract = {Download the Writeup Abstract The Google Titan Security Key is a FIDO U2F hardware device proposed by Google (available since July 2018) as a two-factor authentication token to sign in to applications (e.g. your Google account). Our work describes a side-channel attack that targets the Google Titan Security Key’s secure element (the NXP A700X chip) […]},
	language = {en-US},
	urldate = {2021-06-07},
	journal = {NinjaLab},
}

@misc{noauthor_565_presentationpptx_nodate,
	title = {565\_Presentation.pptx},
	url = {https://docs.google.com/presentation/d/1LgVa3HRk1O4_NJhQ3HafJCFu3op4n0Ep/edit?usp=drive_web&ouid=113039130907653938884&rtpof=true&usp=embed_facebook},
	abstract = {Better WireGuard key management – exploring designs with security keys Peter Van Eenoo},
	language = {en},
	urldate = {2021-06-04},
	journal = {Google Docs},
}

@misc{noauthor_tale_nodate,
	title = {A {Tale} of {Two} {Studies}: {The} {Best} and {Worst} of {YubiKey} {Usability}},
	shorttitle = {A {Tale} of {Two} {Studies}},
	url = {http://ieeexplore.ieee.org/document/8418643},
	abstract = {Two-factor authentication (2FA) significantly improves the security of password-based authentication. Recently, there has been increased interest in Universal 2nd Factor (U2F) security keys-small hardware devices that require users to press a button on the security key to authenticate. To examine the usability of security keys in non-enterprise usage, we conducted two user studies of the YubiKey, a popular line of U2F security keys. The first study tasked 31 participants with configuring a Windows, Google, and Facebook account to authenticate using a YubiKey. This study revealed problems with setup instructions and workflow including users locking themselves out of their operating system or thinking they had successfully enabled 2FA when they had not. In contrast, the second study had 25 participants use a YubiKey in their daily lives over a period of four weeks, revealing that participants generally enjoyed the experience. Conducting both a laboratory and longitudinal study yielded insights into the usability of security keys that would not have been evident from either study in isolation. Based on our analysis, we recommend standardizing the setup process, enabling verification of success, allowing shared accounts, integrating with operating systems, and preventing lockouts.},
	language = {en-US},
	urldate = {2021-06-04},
}

@misc{noauthor_side_nodate-1,
	title = {A {Side} {Journey} to {Titan}},
	url = {https://ninjalab.io/a-side-journey-to-titan/},
	abstract = {Download the Writeup Abstract The Google Titan Security Key is a FIDO U2F hardware device proposed by Google (available since July 2018) as a two-factor authentication token to sign in to applications (e.g. your Google account). Our work describes a side-channel attack that targets the Google Titan Security Key’s secure element (the NXP A700X chip) […]},
	language = {en-US},
	urldate = {2021-06-02},
	journal = {NinjaLab},
	keywords = {titan},
}

@misc{noauthor_cve_nodate,
	title = {{CVE} - {CVE}-2021-3011},
	url = {https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3011},
	urldate = {2021-06-02},
	keywords = {titan},
}

@misc{noauthor_multi-factor_nodate,
	title = {Multi-{Factor} {Authentication} to {Systems} {Login}},
	url = {http://ieeexplore.ieee.org/document/9428806},
	abstract = {Multi-Factor Authentication is an electronic authentication method in which a computer user is granted access to an application or a website only after successfully presenting two or more factors, or pieces of evidence. It is the first step to protect systems against intruders since the traditional log-in methods (username and password) are not completely protected from hackers, since they can guess them easily using tools. Current Systems use additional methods to increase security, such as using two-factor authentication based on a one-time password via mobile or email, or authentication based on biometrics (fingerprint, eye iris or retina, and face recognition) or via token devices. However, these methods require additional hardware equipment with high cost at the level of small and medium companies. This paper proposes a multi-factor authentication system that combines ease of use and low-cost factors. The system does not need any special settings or infrastructure. It relies on graphical passwords, so the user, in registration phase, chooses three images and memorizes them. In the login phase, the user needs only to choose the correct images that he considered during the registration process in a specific order. The proposed system overcomes many different security threats, such as key-loggers, screen capture attack or shoulder surfing. The proposed method was applied to 170 participants, 75\% of them are males and 25\% are females, classified according to their age, education level, web experience. One-third of them did not have sufficient knowledge about various security threats.},
	language = {en-US},
	urldate = {2021-06-02},
}

@inproceedings{dauterman_true2f_2019,
	title = {{True2F}: {Backdoor}-{Resistant} {Authentication} {Tokens}},
	shorttitle = {{True2F}},
	doi = {10.1109/SP.2019.00048},
	abstract = {We present True2F, a system for second-factor authentication that provides the benefits of conventional authentication tokens in the face of phishing and software compromise, while also providing strong protection against token faults and backdoors. To do so, we develop new lightweight two-party protocols for generating cryptographic keys and ECDSA signatures, and we implement new privacy defenses to prevent cross-origin token-fingerprinting attacks. To facilitate real-world deployment, our system is backwards-compatible with today's U2F-enabled web services and runs on commodity hardware tokens after a firmware modification. A True2F-protected authentication takes just 57ms to complete on the token, compared with 23ms for unprotected U2F.},
	booktitle = {2019 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Dauterman, Emma and Corrigan-Gibbs, Henry and Mazières, David and Boneh, Dan and Rizzo, Dominic},
	month = may,
	year = {2019},
	note = {ISSN: 2375-1207},
	keywords = {Authentication, Browsers, Hardware, Protocols, Public key, Standards, authentication, embedded-systems, privacy, security},
	pages = {398--416},
}

@inproceedings{dauterman_true2f_2019-1,
	title = {{True2F}: {Backdoor}-{Resistant} {Authentication} {Tokens}},
	shorttitle = {{True2F}},
	doi = {10.1109/SP.2019.00048},
	abstract = {We present True2F, a system for second-factor authentication that provides the benefits of conventional authentication tokens in the face of phishing and software compromise, while also providing strong protection against token faults and backdoors. To do so, we develop new lightweight two-party protocols for generating cryptographic keys and ECDSA signatures, and we implement new privacy defenses to prevent cross-origin token-fingerprinting attacks. To facilitate real-world deployment, our system is backwards-compatible with today's U2F-enabled web services and runs on commodity hardware tokens after a firmware modification. A True2F-protected authentication takes just 57ms to complete on the token, compared with 23ms for unprotected U2F.},
	booktitle = {2019 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Dauterman, Emma and Corrigan-Gibbs, Henry and Mazières, David and Boneh, Dan and Rizzo, Dominic},
	month = may,
	year = {2019},
	note = {ISSN: 2375-1207},
	keywords = {Authentication, Browsers, Hardware, Protocols, Public key, Standards, authentication, embedded-systems, privacy, security},
	pages = {398--416},
}

@misc{noauthor_fido_nodate,
	title = {{FIDO} {Alliance} {Specifications} {Overview}},
	url = {https://fidoalliance.org/specifications/},
	abstract = {User Authentication Specifications The FIDO Alliance has published three sets of specifications for simpler, stronger user authentication: FIDO Universal Second Factor (FIDO U2F), FIDO Universal Authentication Framework (FIDO UAF) and […]},
	language = {en},
	urldate = {2021-06-02},
	journal = {FIDO Alliance},
	keywords = {fido},
}

@misc{evander_pierre_technical_nodate,
	title = {Technical {Specifications}},
	url = {https://nfc-forum.org/our-work/specification-releases/specifications/nfc-forum-technical-specifications/},
	abstract = {How to Get SpecificationsMembers: NFC Forum members may download the specifications directly for free.Member Access to Technical Specifications {\textgreater}Non-Members: NFC Forum Technical Specifications are available for purchase. Please use the link below to access the Shopping Cart.Non-Members: Purchase NFC Forum Technical Specifications {\textgreater}},
	language = {en-US},
	urldate = {2021-06-02},
	journal = {NFC Forum},
	author = {Evander Pierre},
	keywords = {nfc},
}

@misc{noauthor_near-field_2021,
	title = {Near-field communication},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Near-field_communication&oldid=1023795578},
	abstract = {Near-Field Communication (NFC) is a set of communication protocols for communication between two electronic devices over a distance of 4 cm (11⁄2 in) or less. NFC offers a low-speed connection with simple setup that can be used to bootstrap more-capable wireless connections.NFC devices can act as electronic identity documents and keycards. They are used in contactless payment systems and allow mobile payment  replacing or supplementing systems such as credit cards and electronic ticket smart cards. This is sometimes called NFC/CTLS or CTLS NFC, with contactless abbreviated CTLS.  NFC can be used for sharing small files such as contacts, and bootstrapping fast connections to share larger media such as photos, videos, and other files.},
	language = {en},
	urldate = {2021-06-01},
	journal = {Wikipedia},
	month = may,
	year = {2021},
	note = {Page Version ID: 1023795578},
	keywords = {nfc},
}

@misc{noauthor_rfc5996_nodate,
	title = {rfc5996},
	url = {https://datatracker.ietf.org/doc/html/rfc5996},
	urldate = {2021-06-01},
	keywords = {ikev2},
}

@inproceedings{alqubaisi_should_2020,
	title = {Should {We} {Rush} to {Implement} {Password}-less {Single} {Factor} {FIDO2} based {Authentication}?},
	doi = {10.1109/URC49805.2020.9099190},
	abstract = {Fast Identity Online (FIDO) Alliance and W3C have defined a set of specifications (called FIDO2) that allows a user to replace the password based authentication system. However, none of the high profile web sites have implemented FIDO2 yet as password-less single factor (SF) authentication (password-less SF). In this paper, we analyze the set of factors that make websites reluctant to adopt password-less FIDO SF authentication. We start by comparing the threat models of password-less FIDO SF authentication with password-based SF authentication. Our analysis shows that although password-based authentication is less secure than FIDO SF authentication, other factors related to the usability of FIDO security keys and FIDO based authentication system, the non-consideration of enterprise requirements and the lack of specifications regarding account recovery/deletion and suspension are the main obstacles to the adoption of password-less FIDO SF authentication.},
	booktitle = {2020 12th {Annual} {Undergraduate} {Research} {Conference} on {Applied} {Computing} ({URC})},
	author = {Alqubaisi, Fatima and Wazan, Ahmad Samer and Ahmad, Liza and Chadwick, David W},
	month = apr,
	year = {2020},
	keywords = {Authentication, FIDO2, Password, Password based authentication, Protocols, Servers, UAF, W3C, WebAuthn, fido, threat model},
	pages = {1--6},
}

@misc{noauthor_notitle_nodate,
	url = {https://sc4.us/hsm/buy.html},
	urldate = {2021-05-31},
	keywords = {SC4},
}

@misc{noauthor_frontpage_nodate,
	title = {Frontpage},
	url = {https://www.nitrokey.com/frontpage},
	abstract = {Be prepared for the awesome secure Nitrokey! Subscribe to the upcoming crowdfunding campaign. \#SecureYourDigitalLife https://nitrokey.com/},
	language = {en},
	urldate = {2021-05-31},
	keywords = {nitro},
}

@misc{noauthor_yubihsm2_nodate,
	title = {{YubiHSM2}},
	url = {https://developers.yubico.com/YubiHSM2/},
	urldate = {2021-05-26},
	keywords = {HSM},
}

@misc{noauthor_pass_nodate,
	title = {Pass: {The} {Standard} {Unix} {Password} {Manager}},
	url = {https://www.passwordstore.org/},
	urldate = {2021-05-26},
	keywords = {linux, pass, tools},
}

@misc{noauthor_perfect_nodate,
	title = {The perfect password manager — palkeo},
	url = {https://www.palkeo.com/en/blog/perfect-password-manager.html},
	urldate = {2021-05-26},
	keywords = {gpg, pass},
}

@misc{noauthor_perfect_nodate-1,
	title = {The perfect password manager — palkeo},
	url = {https://www.palkeo.com/en/blog/perfect-password-manager.html},
	urldate = {2021-05-26},
}

@inproceedings{ferdous_formalising_2016,
	title = {Formalising {Identity} {Management} protocols},
	doi = {10.1109/PST.2016.7906948},
	abstract = {In this paper we present the formalisation of three well-known Identity Management protocols - SAML, OpenID and OAuth. The formalisation consists of two steps: formal specification using HLPSL (High-Level Protocol Specification Language) and formal verification using a state-of-the-art verification tool for security protocols called AVISPA (Automated Validation of Internet Security Protocols and Applications). The existing formalisation initiatives using AVISPA are based on SAML and OpenID, leaving OAuth entirely, even though OAuth is one of the most widely-used Internet protocols. Furthermore, the motivation of the existing initiatives was to identify any weakness. In this paper, we have taken an opposite approach as we are keen to present how to model these protocols correctly. Moreover, our formalisation is based on a model of identity and also captures the authentication mechanism; both of these are missing in the existing works.},
	booktitle = {2016 14th {Annual} {Conference} on {Privacy}, {Security} and {Trust} ({PST})},
	author = {Ferdous, Md Sadek and Poet, Ron},
	month = dec,
	year = {2016},
	keywords = {AVISPA, Authentication, Authorization, Formalisation, Identity Management, Internet, Mathematical model, OAuth, OpenID, Protocols, SAML, Servers},
	pages = {137--146},
}

@inproceedings{naik_securing_2017,
	title = {Securing digital identities in the cloud by selecting an apposite {Federated} {Identity} {Management} from {SAML}, {OAuth} and {OpenID} {Connect}},
	doi = {10.1109/RCIS.2017.7956534},
	abstract = {Access to computer systems and the information held on them, be it commercially or personally sensitive, is naturally, strictly controlled by both legal and technical security measures. One such method is digital identity, which is used to authenticate and authorize users to provide access to IT infrastructure to perform official, financial or sensitive operations within organisations. However, transmitting and sharing this sensitive information with other organisations over insecure channels always poses a significant security and privacy risk. An example of an effective solution to this problem is the Federated Identity Management (FIdM) standard adopted in the cloud environment. The FIdM standard is used to authenticate and authorize users across multiple organisations to obtain access to their networks and resources without transmitting sensitive information to other organisations. Using the same authentication and authorization details among multiple organisations in one federated group, it protects the identities and credentials of users in the group. This protection is a balance, mitigating security risk whilst maintaining a positive experience for users. Three of the most popular FIdM standards are Security Assertion Markup Language (SAML), Open Authentication (OAuth), and OpenID Connect (OIDC). This paper presents an assessment of these standards considering their architectural design, working, security strength and security vulnerability, to cognise and ascertain effective usages to protect digital identities and credentials. Firstly, it explains the architectural design and working of these standards. Secondly, it proposes several assessment criteria and compares functionalities of these standards based on the proposed criteria. Finally, it presents a comprehensive analysis of their security vulnerabilities to aid in selecting an apposite FIdM. This analysis of security vulnerabilities is of great significance because their improper or erroneous deployment may be exploited for attacks.},
	booktitle = {2017 11th {International} {Conference} on {Research} {Challenges} in {Information} {Science} ({RCIS})},
	author = {Naik, Nitin and Jenkins, Paul},
	month = may,
	year = {2017},
	note = {ISSN: 2151-1357},
	keywords = {Authentication, Authorization, DoS, FIdM, Federated Identity Management, MITM, Markup languages, OAuth, OpenID Connect, Protocols, SAML, SSO, Servers, Standards, XSS},
	pages = {163--174},
}

@misc{noauthor_fido_nodate-1,
	title = {{FIDO} {Alliance} {Specifications} {Overview}},
	url = {https://fidoalliance.org/specifications/},
	abstract = {User Authentication Specifications The FIDO Alliance has published three sets of specifications for simpler, stronger user authentication: FIDO Universal Second Factor (FIDO U2F), FIDO Universal Authentication Framework (FIDO UAF) and […]},
	language = {en},
	urldate = {2021-05-04},
	journal = {FIDO Alliance},
}

@misc{noauthor_how_nodate,
	title = {How {FIDO} {Works} - {Standard} {Public} {Key} {Cryptography} \& {User} {Privacy}},
	url = {https://fidoalliance.org/how-fido-works/},
	abstract = {FIDO protocols use standard public key cryptography techniques to provide stronger authentication and designed from the ground up to protect user privacy.},
	language = {en},
	urldate = {2021-05-04},
	journal = {FIDO Alliance},
}

@inproceedings{donenfeld_wireguard_2017,
	address = {San Diego, CA},
	title = {{WireGuard}: {Next} {Generation} {Kernel} {Network} {Tunnel}},
	isbn = {978-1-891562-46-4},
	shorttitle = {{WireGuard}},
	url = {https://www.ndss-symposium.org/ndss2017/ndss-2017-programme/wireguard-next-generation-kernel-network-tunnel/},
	doi = {10.14722/ndss.2017.23160},
	abstract = {WireGuard is a secure network tunnel, operating at layer 3, implemented as a kernel virtual network interface for Linux, which aims to replace both IPsec for most use cases, as well as popular user space and/or TLS-based solutions like OpenVPN, while being more secure, more performant, and easier to use. The virtual tunnel interface is based on a proposed fundamental principle of secure tunnels: an association between a peer public key and a tunnel source IP address. It uses a single round trip key exchange, based on NoiseIK, and handles all session creation transparently to the user using a novel timer state machine mechanism. Short pre-shared static keys—Curve25519 points—are used for mutual authentication in the style of OpenSSH. The protocol provides strong perfect forward secrecy in addition to a high degree of identity hiding. Transport speed is accomplished using ChaCha20Poly1305 authenticated-encryption for encapsulation of packets in UDP. An improved take on IP-binding cookies is used for mitigating denial of service attacks, improving greatly on IKEv2 and DTLS’s cookie mechanisms to add encryption and authentication. The overall design allows for allocating no resources in response to received packets, and from a systems perspective, there are multiple interesting Linux implementation techniques for queues and parallelism. Finally, WireGuard can be simply implemented for Linux in less than 4,000 lines of code, making it easily audited and veriﬁed.},
	language = {en},
	urldate = {2021-05-04},
	booktitle = {Proceedings 2017 {Network} and {Distributed} {System} {Security} {Symposium}},
	publisher = {Internet Society},
	author = {Donenfeld, Jason A.},
	year = {2017},
}

@misc{donenfeld_wireguard_nodate,
	title = {{WireGuard}: fast, modern, secure {VPN} tunnel},
	shorttitle = {{WireGuard}},
	url = {https://www.wireguard.com/},
	abstract = {WireGuard: fast, modern, secure VPN tunnel},
	language = {en},
	urldate = {2021-05-04},
	author = {Donenfeld, Jason A.},
}

@misc{noauthor_privacy-preserving_nodate,
	title = {Privacy-preserving neural networks with {Homomorphic} encryption: {Challenges} and opportunities-{Web} of {Science} {Core} {Collection}},
	url = {https://www-webofscience-com.offcampus.lib.washington.edu/wos/woscc/full-record/WOS:000626447700001},
	urldate = {2021-05-01},
}

@article{jacomme_extensive_2021,
	title = {An {Extensive} {Formal} {Analysis} of {Multi}-factor {Authentication} {Protocols}},
	volume = {24},
	issn = {2471-2566},
	url = {http://doi.org/10.1145/3440712},
	doi = {10.1145/3440712},
	abstract = {Passwords are still the most widespread means for authenticating users, even though they have been shown to create huge security problems. This motivated the use of additional authentication mechanisms in so-called multi-factor authentication protocols. In this article, we define a detailed threat model for this kind of protocol: While in classical protocol analysis attackers control the communication network, we take into account that many communications are performed over TLS channels, that computers may be infected by different kinds of malware, that attackers could perform phishing, and that humans may omit some actions. We formalize this model in the applied pi calculus and perform an extensive analysis and comparison of several widely used protocols—variants of Google 2-step and FIDO’s U2F (Yubico’s Security Key token). The analysis is completely automated, generating systematically all combinations of threat scenarios for each of the protocols and using the PROVERIF tool for automated protocol analysis. To validate our model and attacks, we demonstrate their feasibility in practice, even though our experiments are run in a laboratory environment. Our analysis highlights weaknesses and strengths of the different protocols. It allows us to suggest several small modifications of the existing protocols that are easy to implement, as well as an extension of Google 2-step that improves security in several threat scenarios.},
	number = {2},
	urldate = {2021-05-01},
	journal = {ACM Transactions on Privacy and Security},
	author = {Jacomme, Charlie and Kremer, Steve},
	month = jan,
	year = {2021},
	keywords = {Formal methods, detailed threat models, multi-factor authentication, symbolic model},
	pages = {13:1--13:34},
}

@article{jacomme_extensive_2021-1,
	title = {An {Extensive} {Formal} {Analysis} of {Multi}-factor {Authentication} {Protocols}},
	volume = {24},
	issn = {2471-2566},
	url = {http://doi.org/10.1145/3440712},
	doi = {10.1145/3440712},
	abstract = {Passwords are still the most widespread means for authenticating users, even though they have been shown to create huge security problems. This motivated the use of additional authentication mechanisms in so-called multi-factor authentication protocols. In this article, we define a detailed threat model for this kind of protocol: While in classical protocol analysis attackers control the communication network, we take into account that many communications are performed over TLS channels, that computers may be infected by different kinds of malware, that attackers could perform phishing, and that humans may omit some actions. We formalize this model in the applied pi calculus and perform an extensive analysis and comparison of several widely used protocols—variants of Google 2-step and FIDO’s U2F (Yubico’s Security Key token). The analysis is completely automated, generating systematically all combinations of threat scenarios for each of the protocols and using the PROVERIF tool for automated protocol analysis. To validate our model and attacks, we demonstrate their feasibility in practice, even though our experiments are run in a laboratory environment. Our analysis highlights weaknesses and strengths of the different protocols. It allows us to suggest several small modifications of the existing protocols that are easy to implement, as well as an extension of Google 2-step that improves security in several threat scenarios.},
	number = {2},
	urldate = {2021-05-01},
	journal = {ACM Transactions on Privacy and Security},
	author = {Jacomme, Charlie and Kremer, Steve},
	month = jan,
	year = {2021},
	keywords = {Formal methods, detailed threat models, multi-factor authentication, symbolic model},
	pages = {13:1--13:34},
}

@misc{noauthor_research_nodate,
	title = {Research {Proposal} - {Part} {I}},
	url = {https://canvas.uw.edu/courses/1465684/assignments/6290506},
	urldate = {2021-05-01},
}

@misc{june_16_raspberry_nodate,
	title = {Raspberry {Pi} {GPIO} {Pinout}: {What} {Each} {Pin} {Does} on {Pi} 4, {Earlier} {Models}},
	shorttitle = {Raspberry {Pi} {GPIO} {Pinout}},
	url = {https://www.tomshardware.com/reviews/raspberry-pi-gpio-pinout,6122.html},
	abstract = {The Raspberry Pi has 40 GPIO pins that connect to sensors, lights, motors and other devices. Here's a map and detailed explanation of what each does, including on the Pi 4.},
	language = {en},
	urldate = {2021-03-16},
	journal = {Tom's Hardware},
	author = {June 16, Les Pounder and {2020}},
}

@misc{noauthor_sleepy_nodate,
	title = {Sleepy {Pi}},
	url = {https://spellfoundry.com/sleepy-pi/},
	abstract = {An add-on board for the Raspberry Pi that adds a virtual low power mode to it along with an Arduino controller, Analogue I/P and GPIO breakout.},
	language = {en-US},
	urldate = {2021-03-16},
	journal = {Spell Foundry},
}

@misc{noauthor_raspberry_nodate,
	title = {Raspberry {Pi} {Zero} {W} board - {Deep} {Sleep} {Mode} configuration and wake up - {Raspberry} {Pi} {Forums}},
	url = {https://www.raspberrypi.org/forums/viewtopic.php?t=242984},
	urldate = {2021-03-16},
}

@misc{noauthor_printed_2021,
	title = {Printed circuit board},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Printed_circuit_board&oldid=1012323672},
	abstract = {A printed circuit board (PCB) mechanically supports and electrically connects electrical or electronic components using conductive tracks, pads and other features etched from one or more sheet layers of copper laminated onto and/or between sheet layers of a non-conductive substrate. Components are generally soldered onto the PCB to both electrically connect and mechanically fasten them to it.
Printed circuit boards are used in all but the simplest electronic products. They are also used in some electrical products, such as passive switch boxes.
Alternatives to PCBs include wire wrap and point-to-point construction, both once popular but now rarely used. PCBs require additional design effort to lay out the circuit, but manufacturing and assembly can be automated. Electronic computer-aided design software is available to do much of the work of layout. Mass-producing circuits with PCBs is cheaper and faster than with other wiring methods, as components are mounted and wired in one operation.  Large numbers of PCBs can be fabricated at the same time, and the layout only has to be done once.  PCBs can also be made manually in small quantities, with reduced benefits.
PCBs can be single-sided (one copper layer), double-sided (two copper layers on both sides of one substrate layer), or multi-layer (outer and inner layers of copper, alternating with layers of substrate).  Multi-layer PCBs allow for much higher component density, because circuit traces on the inner layers would otherwise take up surface space between components.  The rise in popularity of multilayer PCBs with more than two, and especially with more than four, copper planes was concurrent with the adoption of surface mount technology.  However, multilayer PCBs make repair, analysis, and field modification of circuits much more difficult and usually impractical.
The world market for bare PCBs exceeded \$60.2 billion in 2014 and is estimated to reach \$79 billion by 2024.},
	language = {en},
	urldate = {2021-03-16},
	journal = {Wikipedia},
	month = mar,
	year = {2021},
	note = {Page Version ID: 1012323672},
}

@misc{soren_making_2018,
	title = {Making a {LED} blink using the {Raspberry} {Pi} and {Python} {\textbar} {Raspberry} {Pi} {HQ}},
	url = {https://raspberrypihq.com/making-a-led-blink-using-the-raspberry-pi-and-python/},
	abstract = {This tutorial will guide you through setting up the circuit and connecting it to the Raspberry Pi using the GPIO ports as well as how to write the Python script that makes the LED blink.},
	language = {en-US},
	urldate = {2021-03-16},
	author = {{Soren}},
	month = jan,
	year = {2018},
}

@inproceedings{kasah_investigation_2020,
	title = {Investigation on {6LoWPAN} {Data} {Security} for {Internet} of {Things}},
	doi = {10.1109/ICCIS49240.2020.9257661},
	abstract = {Low-power wireless network technology is one of the main key characteristics in communication systems that are needed by the Internet of Things (IoT). Nowadays, the 6LoWPAN standard is one of the communication protocols which has been identified as an important protocol in IoT applications. Networking technology in 6LoWPAN transfer IPv6 packets efficiently in link-layer framework that is well-defined by IEEE 802.14.5 protocol. 6Lo WPAN development is still having problems such as threats and entrust crises. The most important part when developing this new technology is the challenge to secure the network. Data security is viewed as a major consideration in this network communications. Many researchers are working to secure 6LoWPAN communication by analyzing the architecture and network features. 6LoWPAN security weakness or vulnerability is exposed to various forms of network attack. In this paper, the security solutions for 6LoWPAN have been investigated. The requirements of safety in 6LoWPAN are also presented.},
	booktitle = {2020 2nd {International} {Conference} on {Computer} and {Information} {Sciences} ({ICCIS})},
	author = {Kasah, N. b H. and Aman, A. H. b M. and Attarbashi, Z. S. M. and Fazea, Y.},
	month = oct,
	year = {2020},
	keywords = {6Lo WPAN development, 6LoWPAN, 6LoWPAN communication, 6LoWPAN standard, 6LoWPAN transfer IPv6 packets, Authentication, Communication system security, IP networks, Internet of Things, Internet of Things (IoT), IoT applications, IoT security, Routing protocols, Security, Wireless communication, Wireless sensor networks, communication protocols, communication systems, data security, important protocol, low-power wireless network technology, main key characteristics, network attack, network communications, networking technology, personal area networks, protocols, security solutions, telecommunication security, vulnerability},
	pages = {1--5},
}

@inproceedings{ishak_smart_2017,
	title = {Smart home garden irrigation system using {Raspberry} {Pi}},
	doi = {10.1109/MICC.2017.8311741},
	abstract = {Irrigation system is a method of allowing water to drip slowly to the roots of plants, either onto the soil surface or directly onto the root zone, through solenoid valve. However, it is found that the market price of the system is expensive for small area coverage. Thus, this paper proposes a design for smart home garden irrigation system that implements ready-to-use, energy-efficient, and cost effective devices. Raspberry Pi, which is implemented in this system is integrated with multi-sensors such as soil moisture sensors, ultrasonic sensors, and light sensors. This proposed system managed to reduce cost, minimize waste water, and reduce physical human interface. In this paper, the relay is utilized to control the switching of solenoid valve. The system also managed to measure moisture of the soil and control the solenoid valve according to human's requirements. It is conducted with Graphical User Interface (GUI) using Android application to activate watering activity. Email notification is also sent to the home user for alert purposes either for normal or critical operations. An experimental setup has been tested and it is proven that the system can intelligently control and monitor the soil moisture levels in the experiment field.},
	booktitle = {2017 {IEEE} 13th {Malaysia} {International} {Conference} on {Communications} ({MICC})},
	author = {Ishak, S. N. and Malik, N. N. N. A. and Latiff, N. M. A. and Ghazali, N. E. and Baharudin, M. A.},
	month = nov,
	year = {2017},
	keywords = {Android (operating system), Android application, Androids, GUI, Humanoid robots, Intelligent sensors, Irrigation, Light Sensor, Moisture Sensor, Monitoring, Raspberry Pi, Sensor systems, Smart Irrigation System, Solenoid Valve, Ultrasonic Sensor, component, computerised monitoring, graphical user interface, graphical user interfaces, intelligent sensors, irrigation, level measurement, light sensors, moisture measurement, multisensors, physical human interface reduction, raspberry Pi, root zone, sensor fusion, smart home garden irrigation system, soil, soil moisture level measurement, soil moisture sensors, soil surface, solenoid valve, solenoids, ultrasonic sensors, valves, wastewater minimization},
	pages = {101--106},
}

@misc{finiofollow_raspberry_nodate,
	title = {Raspberry {Pi} {Controlled} {Irrigation} {System}},
	url = {https://www.instructables.com/Raspberry-Pi-Controlled-Irrigation-System/},
	abstract = {Raspberry Pi Controlled Irrigation System: Every spring my wife gets really ambitious and plants a big vegetable garden. As the summer drags on, ambition turns to laziness and unfortunately many of the plants die a slow, withering death from neglect due to lack of weeding and watering (excep…},
	language = {en},
	urldate = {2021-03-15},
	journal = {Instructables},
	author = {FinioFollow, Ben},
}

@misc{foundation_operating_nodate,
	title = {Operating system images},
	url = {https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit},
	abstract = {The Raspberry Pi is a tiny and affordable computer that you can use to learn programming through fun, practical projects. Join the global Raspberry Pi community.},
	language = {en-GB},
	urldate = {2021-03-14},
	journal = {Raspberry Pi},
	author = {Foundation, The Raspberry Pi},
}

@misc{noauthor_qualification_nodate,
	title = {Qualification {Fees}},
	url = {https://www.bluetooth.com/develop-with-bluetooth/qualification-listing/qualification-listing-fees/},
	abstract = {Qualification fees fund the future of Bluetooth All members are required to complete the Qualification and Declaration process, which includes payment of the Declaration fee through our online…},
	language = {en-US},
	urldate = {2021-03-14},
	journal = {Bluetooth® Technology Website},
}

@misc{saturday_night_live_misunderstood_2018,
	title = {The {Misunderstood} {Nature} of {Entropy}},
	url = {https://www.youtube.com/watch?v=kfffy12uQ7g},
	abstract = {Viewers like you help make PBS (Thank you 😃) . Support your local PBS Member Station here: https://to.pbs.org/DonateSPACE​

Entropy and the second law of thermodynamics has been credited with defining the arrow of time.

You can further support us on Patreon at https://www.patreon.com/pbsspacetime​

Get your own Space Time t­-shirt at http://bit.ly/1QlzoBi​

Tweet at us! @pbsspacetime
Facebook: facebook.com/pbsspacetime
Email us! pbsspacetime [at] gmail [dot] com
Comment on Reddit: http://www.reddit.com/r/pbsspacetime​

Help translate our videos!
https://www.youtube.com/timedtext\_cs\_​...

Previous Episode:
Quantum Invariance \&amp; The Origin of The Standard Model
https://www.youtube.com/watch?v=V5kgr...​

Entropy is surely one of the most intriguing and misunderstood concepts in all of physics. The entropy of the universe must always increase – so says the second law of thermodynamics.  It’s a law that seems emergent from deeper laws – it’s statistical in nature – and yet may ultimately be more fundamental and unavoidable than any other law of physics.
 
Hosted by Matt O'Dowd
Written Matt O'Dowd
Graphics by Grayson Blackmon
Assistant Editing and Sound Design by Mike Petrow
Made by Kornhaber Brown (www.kornhaberbrown.com)

Special thanks to our Patreon Big Bang, Quasar and Hypernova Supporters: 

Big Bang
CoolAsCats
David Nicklas
Anton Lifshits
Joey Redner
Fabrice Eap

Quasar
Tambe Barsbay
Mayank M. Mehrota
Mars Yentur
Mark Rosenthal
Dean Fuqua
Roman Pinchuk
ColeslawPurdie
Vinnie Falco

Hypernova
Donal Botkin
Edmund Fokschaner
Matthew O’Connor
Eugene Lawson
Barry Hatfield
Martha Hunt
Joseph Salomone
Chuck Zegar
Craig Peterson
Jordan Young
Ratfeast
John Hofmann


Thanks to our Patreon Gamma Ray Burst Supporters: 
James Hughes
Fabian Olesen
Kris Fernet
Jane Meyers
James Flowers
Greg Allen
Denys Ivanov
Nick Virtue
Alexey Eromenko
Nicholas Rose
Scott Gossett
Mark Vasile
Patrick Murray
سلطان الخليفي
Alex Seto
Michal-Peanut Karmi
Erik Stein
Kevin Warne
JJ Bagnell
Avi Goldfinger
John Pettit
Florian Stinglmayr
Benoit Pagé-Guitard
Nathan Leniz
Brandon Labonte
David Crane
Greg Weiss
Shannan Catalano
Brandon Cook
Malte Ubl},
	urldate = {2021-03-14},
	author = {{Saturday Night Live}},
	month = jul,
	year = {2018},
}

@misc{noauthor_raspberry_nodate-1,
	title = {Raspberry {Pi} 802.15.4 radio - openlabs.co},
	url = {https://openlabs.co/store/Raspberry-Pi-802.15.4-radio},
	urldate = {2021-03-13},
}

@misc{noauthor_kuman_nodate,
	title = {Kuman {5PCS} {Soil} {Moisture} {Sensor} {Kit} with {Jumer} and {DuPont} cables for {Raspberry} pi {Arduino} {Uno} {R3} {Mega} 2560 {Automatic} {Watering} {System} {KY70}},
	url = {http://www.kumantech.com/kuman-5pcs-soil-moisture-sensor-kit-with-jumer-and-dupont-cables-for-raspberry-pi-arduino-uno-r3-mega-2560-automatic-watering-system-ky70_p0389.html},
	abstract = {Kuman 5PCS Soil Moisture Sensor Kit with Jumer and DuPont cables for Raspberry pi Arduino Uno R3 Mega 2560 Automatic Watering System KY70,Sensor Kits,Project Electronics},
	language = {en},
	urldate = {2021-03-13},
}

@misc{foundation_buy_nodate,
	title = {Buy a {Raspberry} {Pi} {Zero}},
	url = {https://www.raspberrypi.org/products/raspberry-pi-zero/},
	abstract = {The Raspberry Pi Zero is half the size of a Model A+, with twice the utility. A tiny Raspberry Pi that’s affordable enough for any project!},
	language = {en-GB},
	urldate = {2021-03-13},
	journal = {Raspberry Pi},
	author = {Foundation, The Raspberry Pi},
}

@misc{noauthor_esp32_nodate,
	title = {{ESP32}: {Tips} to increase battery life},
	shorttitle = {{ESP32}},
	url = {https://www.savjee.be/2019/12/esp32-tips-to-increase-battery-life/},
	abstract = {Running an ESP32 on a battery is a tricky operation. The chip is a powerhouse, and with power comes great responsibility. In this post, I’ll outline how I got an ESP32 to run for over 15 weeks (and counting) on a single 1000mAh battery.},
	language = {en},
	urldate = {2021-03-13},
	journal = {Savjee.be},
}

@misc{noauthor_power_nodate,
	title = {Power {Consumption} {Benchmarks} {\textbar} {Raspberry} {Pi} {Dramble}},
	url = {https://www.pidramble.com/wiki/benchmarks/power-consumption},
	urldate = {2021-03-13},
}

@misc{noauthor_ieee_nodate,
	title = {{IEEE} 802.11, {The} {Working} {Group} {Setting} the {Standards} for {Wireless} {LANs}},
	url = {https://www.ieee802.org/11/},
	urldate = {2021-03-13},
}

@inproceedings{sulaiman_iot-based_2019,
	title = {An {IoT}-based {Smart} {Garden} with {Weather} {Station} {System}},
	doi = {10.1109/ISCAIE.2019.8743837},
	abstract = {Internet of Things (IoT) consists of devices that connect to the internet and communicate with each other. It enables these devices to collect and exchange data with a consumer. This paper presents an IoT-based Smart Garden with Weather Station system, which can be used to monitor the growth of plant every day and predict the probability for raining. Why this IoT-based device is been created? Many people are interested in growing the plants are always forget on watering the plants. Hence, in this study, the device is equipped with a water pump, where it can be monitored and controlled by using a smartphone. In addition, the devices also consist of four main sensors, which are Barometric Pressure, DHT11 Temperature, and Humidity Sensor, Soil Moisture Sensor and Light intensity module sensor. The Soil and Light Intensity sensor used to measure the value by percentages. Besides, two actuators, which are the water pump and LED light can be used remotely or by using a button on the devices. The LED is purposely to replicate the sunlight and make the plant grow faster. This IoT-based Smart Garden with Weather Station System can record the data and send the result to user through the smartphone application named as Blynk apps. This research is beneficial, and the system can be easily managed by all users such as researcher or farmer, and children.},
	booktitle = {2019 {IEEE} 9th {Symposium} on {Computer} {Applications} {Industrial} {Electronics} ({ISCAIE})},
	author = {Sulaiman, N. b Arbain and Sadli, M. D. Darrawi bin},
	month = apr,
	year = {2019},
	keywords = {Arduino Uno, Blynk Apps, Blynk apps, DHT11 temperature sensor, Humidity, Internet of Things, IoT-based smart garden device, Light emitting diodes, NodeMCU, Smart Garden, Soil, Temperature measurement, Temperature sensors, Weather Station, barometers, barometric pressure sensor, computerised instrumentation, humidity measurement, humidity sensor, humidity sensors, light emitting diodes, light intensity module sensor, optical sensors, pressure measurement, pressure sensors, probability, smartphone, soil moisture sensor, temperature measurement, temperature sensors, water pump, water pumps, weather station system},
	pages = {38--43},
}

@inproceedings{al-omary_cloud_2018,
	title = {Cloud based {IoT} for smart garden watering system using {Arduino} {Uno}},
	doi = {10.1049/cp.2018.1401},
	abstract = {Automation the process of monitoring the garden can transform garden irrigation process from being manual and static to smart and dynamic one. This leads to higher comfortability, water using efficiency and less human supervision effort. This paper proposes a cloud based Internet of Things (IoT) smart garden monitoring and irrigation system using Arduino Uno. The watering requirement for a plant can be adjusted by monitoring the soil moisture. Measuring the soil moisture of the plant gives information if the plant is ideally watered, over watered or under watered. The proposed system monitors and maintains two quantities of the garden, the garden soil moisture content and light intensity. This is done using soil moisture sensors and light intensity sensor. The monitored data is sent continuously to ThinkSpeak IoT cloud. In the cloud the data gathered from the system is analyzed and when a target threshold of soil moister is reached, an action is sent accordingly from the cloud to the garden automatic watering system to irrigate the garden. Arduino Uno microcontroller is used to implement the system control unit. IoT is used to keep the garden owner updated about the status of the sprinklers. Information from the sensors is regularly updated on a ThinSpeack IoT cloud and the user can check the water sprinklers status at any time. In addition, the sensor readings are transmitted to a ThingSpeak channel to generate graphs for analysis.},
	booktitle = {​{Smart} {Cities} {Symposium} 2018},
	author = {Al-Omary, A. and AlSabbagh, H. M. and Al-Rizzo, H.},
	month = apr,
	year = {2018},
	keywords = {Arduino Uno, Cloud computing, IoT, Smart garden, ThinkSpeak},
	pages = {1--6},
}

@misc{noauthor_mqtt_nodate,
	title = {{MQTT} {Version} 3.1.1},
	url = {https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html},
	urldate = {2021-03-13},
}

@misc{kushalnagar_transmission_nodate,
	title = {Transmission of {IPv6} {Packets} over {IEEE} 802.15.4 {Networks}},
	url = {https://tools.ietf.org/html/rfc4944},
	language = {en},
	urldate = {2021-03-13},
	author = {Kushalnagar, Nandakishore and Montenegro, Gabriel},
}

@inproceedings{sukhdev_iot_2018,
	title = {{IoT} {Enabled} {Smart} {Gardening}},
	doi = {10.1109/ICINPRO43533.2018.9096672},
	abstract = {Internet of Things (IoT) is the interconnection of physical objects and devices to the internet and in turn to each other to aid decision making. This paper deals with automation of gardening systems using IoT. With water resources becoming ever so scarce by the day, it has become imperative that we use water extremely judiciously in all walks of our daily life. We track the environmental conditions such as humidity of the soil, and temperature and take an appropriate route towards the problem. Based on the data collected, we run algorithms which help keep the garden in good condition and at the same time using resources optimally.},
	booktitle = {2018 {Fourteenth} {International} {Conference} on {Information} {Processing} ({ICINPRO})},
	author = {Sukhdev, N. and Nahata, N. and Sridhara, S. and Swamy, G.},
	month = dec,
	year = {2018},
	keywords = {Fertilizer Advisory, Fertilizers, Garden Maintenance, Internet of Things, IoT, IoT enabled smart gardening, Maintenance engineering, Mobile Application, Moisture, Sensors, Soil, Solenoids, Temperature sensors, decision making, environmental conditions, garden, gardening, gardening systems, physical objects, water resources},
	pages = {1--2},
}

@misc{noauthor_how_nodate-1,
	title = {How {Secure} {Is} the {BLE} {Communication} {Standard}? - {DZone} {Security}},
	shorttitle = {How {Secure} {Is} the {BLE} {Communication} {Standard}?},
	url = {https://dzone.com/articles/how-secure-is-the-ble-communication-standard},
	abstract = {In this article, we discuss potential threats for BLE security and methods for handling these insecurities.},
	language = {en},
	urldate = {2021-03-13},
	journal = {dzone.com},
}

@inproceedings{sivakumaran_low_2018,
	address = {New York, NY, USA},
	series = {{CODASPY} '18},
	title = {A {Low} {Energy} {Profile}: {Analysing} {Characteristic} {Security} on {BLE} {Peripherals}},
	isbn = {978-1-4503-5632-9},
	shorttitle = {A {Low} {Energy} {Profile}},
	url = {http://doi.org/10.1145/3176258.3176945},
	doi = {10.1145/3176258.3176945},
	abstract = {Bluetooth Low Energy is a ubiquitous technology, with applications in the fitness, healthcare and smart home sectors, to name but a few. In this paper, we present an open-source Profiler for classifying the protection level of data residing on a BLE device. Preliminary results obtained by executing the tool against several devices show that some BLE devices allow unauthenticated reads and writes from third party devices. This could expose them to a number of attacks and compromise the privacy, or even the physical safety, of the device owner.},
	urldate = {2021-03-12},
	booktitle = {Proceedings of the {Eighth} {ACM} {Conference} on {Data} and {Application} {Security} and {Privacy}},
	publisher = {Association for Computing Machinery},
	author = {Sivakumaran, Pallavi and Blasco Alis, Jorge},
	month = mar,
	year = {2018},
	keywords = {attribute security, bluetooth low energy, just works, pairing, passkey},
	pages = {152--154},
}

@misc{noauthor_i_nodate,
	title = {Do {I} need a {SensorPush} {G1} {WiFi} {Gateway}, or can {I} just use the sensor?},
	url = {https://support.sensorpush.com/hc/en-us/articles/360052331913-Do-I-need-a-SensorPush-G1-WiFi-Gateway-or-can-I-just-use-the-sensor-},
	abstract = {It all depends on whether or not you need to monitor your sensor remotely and/or if you want to back up or sync your data with others on the SensorPush cloud.
The sensors use Bluetooth LE to commun...},
	language = {en-US},
	urldate = {2021-03-13},
	journal = {SensorPush},
}

@misc{constantin_personal_2015,
	title = {Personal weather stations can expose your {Wi}-{Fi} network},
	url = {https://www.csoonline.com/article/2883910/personal-weather-stations-can-expose-your-wifi-network.html},
	abstract = {In the latest Internet of Things security blunder, personal weather station devices made by Netatmo were found sending users' Wi-Fi passwords back to the company over unencrypted connections.},
	language = {en},
	urldate = {2021-03-13},
	journal = {CSO Online},
	author = {Constantin, Lucian},
	month = feb,
	year = {2015},
}

@misc{noauthor_5--1_nodate,
	title = {5-in-1 {Weather} {Sensor} {\textbar} {AcuRite}},
	url = {https://www.acurite.com/learn/weather-stations/acurite-5-in-1-sensor},
	urldate = {2021-03-13},
}

@misc{noauthor_how_nodate-2,
	title = {How to {Get} the {Best} {Wireless} {Range} {\textbar} {AcuRite}},
	url = {https://www.acurite.com/learn/installation/wireless-signal-range},
	urldate = {2021-03-13},
}

@misc{noauthor_transport_nodate,
	title = {Transport security in {AWS} {IoT} - {AWS} {IoT} {Core}},
	url = {https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html},
	urldate = {2021-03-13},
}

@misc{noauthor_amazoncom_nodate,
	title = {Amazon.com: {AcuRite} {Wireless} {Home} {Station} (01536) with 5-1 {Sensor} and {Android} {iPhone} {Weather} {Monitoring}: {Home} \& {Kitchen}},
	url = {https://www.amazon.com/dp/B06XNPKKNZ?tag=weather.station.guide-20&geniuslink=true},
	urldate = {2021-03-12},
	keywords = {devices},
}

@misc{noauthor_xtra_nodate,
	title = {{XTRA} {SMART}® {Precision}™ {Soil} {Moisture} {Sensor} (53812) {\textbar} {Toro}},
	url = {https://www.toro.com/en/homeowner/irrigation-sensors/xtra-smart-precision-soil-moisture-sensor},
	urldate = {2021-03-12},
	keywords = {devices},
}

@misc{noauthor_amazoncom_nodate-1,
	title = {Amazon.com : {ECOWITT} {WH51} {Soil} {Moisture} {Sensor} {Max} 8 {Channels} {Soil} {Humidity} {Tester} - {Accessory} {Only}, {Can} {Not} {Be} {Used} {Alone} : {Garden} \& {Outdoor}},
	url = {https://www.amazon.com/ECOWITT-Moisture-Sensor-Humidity-Tester/dp/B07JM621R3/ref=sr_1_4?dchild=1&keywords=soil+humidity+sensor+wireless&qid=1615591953&sr=8-4},
	urldate = {2021-03-12},
	keywords = {devices},
}

@misc{noauthor_amazoncom_nodate-2,
	title = {Amazon.com: {SensorPush} {Wireless} {Thermometer}/{Hygrometer} for {iPhone}/{Android} - {Humidity} \& {Temperature} {Smart} {Sensor} with {Alerts}. {Developed} and {Supported} in {The} {USA}: {Home} \& {Kitchen}},
	url = {https://www.amazon.com/SensorPush-Wireless-Thermometer-Hygrometer-Android/dp/B01AEQ9X9I/ref=sr_1_2?dchild=1&keywords=soil+humidity+sensor+wireless&qid=1615591953&sr=8-2},
	urldate = {2021-03-12},
	keywords = {devices},
}

@misc{noauthor_amazoncom_nodate-3,
	title = {Amazon.com : {XLUX} {Soil} {Moisture} {Meter}, {Plant} {Water} {Monitor}, {Soil} {Hygrometer} {Sensor} for {Gardening}, {Farming}, {Indoor} and {Outdoor} {Plants}, {No} {Batteries} {Required} : {Garden} \& {Outdoor}},
	url = {https://www.amazon.com/XLUX-Soil-Moisture-Sensor-Meter/dp/B014MJ8J2U/ref=sr_1_2?dchild=1&keywords=soil+humidity+sensor&qid=1615591918&sr=8-2},
	urldate = {2021-03-12},
	keywords = {devices},
}

@misc{noauthor_awsaws-iot-device-sdk-python-v2_2021,
	title = {aws/aws-iot-device-sdk-python-v2},
	copyright = {Apache-2.0 License         ,                 Apache-2.0 License},
	url = {https://github.com/aws/aws-iot-device-sdk-python-v2},
	abstract = {Next generation AWS IoT Client SDK for Python using the AWS Common Runtime},
	urldate = {2021-03-05},
	publisher = {Amazon Web Services},
	month = mar,
	year = {2021},
	note = {original-date: 2018-11-13T21:52:37Z},
	keywords = {hacktoberfest, python aws},
}

@misc{patel_neighbor_nodate,
	title = {Neighbor {Discovery} {Proxies} ({ND} {Proxy})},
	url = {https://tools.ietf.org/html/rfc4389},
	language = {en},
	urldate = {2021-03-03},
	journal = {Neighbor Discovery Proxies (ND Proxy)},
	author = {Patel, Chirayu and Talwar, Mohit and Thaler, Dave},
}

@misc{noauthor_at86rf233_nodate,
	title = {{AT86RF233} - {Wireless} {Modules}},
	url = {https://www.microchip.com/wwwproducts/en/AT86RF233},
	urldate = {2021-03-03},
}

@misc{foundation_buy_nodate,
	title = {Buy a {Raspberry} {Pi} 3 {Model} {B}+},
	url = {https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/},
	abstract = {1.4GHz 64-bit quad-core processor, dual-band wireless LAN, Bluetooth 4.2/BLE, faster Ethernet, and Power-over-Ethernet support (with separate PoE HAT)},
	language = {en-GB},
	urldate = {2021-03-03},
	journal = {Raspberry Pi},
	author = {Foundation, The Raspberry Pi},
	keywords = {rpi},
}

@inproceedings{fernandez_evaluation_2013,
	title = {Evaluation {Framework} for {IEEE} 802.15.4 and {IEEE} 802.11 for {Smart} {Cities}},
	doi = {10.1109/IMIS.2013.77},
	abstract = {Jemula802 is a simulator developed by Disney Research for the standard IEEE 802.11, more specifically 802.11a/g. Jemula802 is used for simulations on scenarios related with Theme Park deployments. This paper describes the progress of the design and implementation of the IEEE 802.15.4 over Jemula. Jemula802.15.4-adaptation transforms Jemula802 (simulator of IEEE 802.11 standard) into the IEEE 802.15.4 standard simulator. IEEE 802.15.4, standard for low-rate wireless personal area networks (LR-WPANs) that specifies the physical layer and medium access control that is the base for upper layer protocols like Zigbee, MiWi and WirelessHART. Thereby, Jemula is offering a simulator and emulation framework to evaluate and compare deployments based on IEEE 802.11 (WiFi) and IEEE 802.15.4 (Wireless Sensor Networks). In addition, Jemula offers the visualization libraries for theme parks that can be also applied for smart cities. Therefore, Jemula can be considered as a evaluation framework for IEEE 802.15.4 and IEEE 802.11 for Smart Cities.},
	booktitle = {2013 {Seventh} {International} {Conference} on {Innovative} {Mobile} and {Internet} {Services} in {Ubiquitous} {Computing}},
	author = {Fernandez, P. and Jara, A. J. and Skarmeta, A. F. G.},
	month = jul,
	year = {2013},
	keywords = {802.11a/g, Cities and towns, Evaluation framework, IEE 802.15.4, IEEE 802.11, IEEE 802.11 Standards, IEEE 802.15 Standards, IEEE 802.15.4 standard simulator, Internet of Things, IoT, Jemula, Jemula802.15.4-adaptation, LR-WPAN, MiWi, Modulation, Physical layer, Protocols, WiFi, WirelessHART, Zigbee, access protocols, evaluation framework, leisure industry, low-rate wireless personal area network, medium access control, physical layer, power, simulator, smart cities, theme park deployment, upper layer protocol, visualization libraries, wireless LAN, wireless sensor networks},
	pages = {421--426},
}

@inproceedings{henkel_trends_2011,
	title = {Trends in low power frontend development for {IEEE} 802.15.4/{ZigBee}},
	doi = {10.1109/RFIT.2011.6141790},
	abstract = {The IEEE 802.15.4 standard, also known as ZigBee, is the most established standard for Wireless Sensor Networks (WSN). A key parameter in designing a ZigBee frontend is low power consumption, such that the maximum time of operation can be achieved with the available energy. Particularly, the RF Frontend has an important role, since most of the energy is consumed there. As various RF Frontend architectures are suitable for fulfilling the IEEE 802.15.4 standard. This paper focuses on comparing these architectures in terms of low power, complexity and performance. After a short introduction the different RF Frontend architectures are discussed in section 2 and section 3. Section 4 discusses future trends in PA designs for WSN ICs.},
	booktitle = {2011 {IEEE} {International} {Symposium} on {Radio}-{Frequency} {Integration} {Technology}},
	author = {Henkel, F. and Neyer, A. and Din, M. G. E.},
	month = nov,
	year = {2011},
	keywords = {802.15.4, IEEE 802.15 Standards, IEEE 802.15.4 standard, Mixers, Modulation, Power amplifiers, RF Frontend, RF frontend architectures, Radio frequency, Receivers, WSN, Wireless sensor networks, ZigBee, ZigBee frontend, Zigbee, direct conversion, low power consumption, low power frontend development, low-IF, low-power electronics, power, wireless sensor networks},
	pages = {157--160},
}

@misc{newmarch_routing_2017,
	title = {Routing},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://jan.newmarch.name/IoT/LinuxJournal/Routing/},
	language = {English},
	urldate = {2021-02-14},
	journal = {Low power wireless: Routing to the internet},
	author = {newmarch, jan},
	month = jun,
	year = {2017},
	keywords = {guide},
}

@misc{noauthor_iot_nodate,
	title = {{IoT} - a techie's viewpoint},
	url = {https://jan.newmarch.name/IoT/index.html},
	urldate = {2021-03-02},
}

@misc{noauthor_riot-makerswpan-raspbian_nodate,
	title = {{RIOT}-{Makers}/wpan-raspbian},
	url = {https://github.com/RIOT-Makers/wpan-raspbian},
	abstract = {Tools for a WPAN enabled Raspbian. Contribute to RIOT-Makers/wpan-raspbian development by creating an account on GitHub.},
	language = {en},
	urldate = {2021-02-15},
	journal = {GitHub},
	keywords = {howto},
}

@misc{noauthor_riot-makerswpan-raspbian_nodate-1,
	title = {{RIOT}-{Makers}/wpan-raspbian},
	url = {https://github.com/RIOT-Makers/wpan-raspbian},
	abstract = {Tools for a WPAN enabled Raspbian. Contribute to RIOT-Makers/wpan-raspbian development by creating an account on GitHub.},
	language = {en},
	urldate = {2021-03-02},
	journal = {GitHub},
	keywords = {howto},
}

@inproceedings{dae-in_choi_ipv6_2011,
	title = {{IPv6} global connectivity for {6LoWPAN} using short {ID}},
	isbn = {978-1-61284-661-3},
	doi = {10.1109/ICOIN.2011.5723133},
	abstract = {6LoWPAN is for IPv6 packets to be sent to and received from over IEEE 802.15.4 based networks for applications which require wireless internet connectivity at lower data rates for devices. However it is well known that the management of addresses for devices that communicate across the two dissimilar domains of IPv6 and IEEE802.15.4 is complicated. Routing itself is another problem especially between the IPv6 domain and the IEEE802.15.4 domain. IEEE802.15.4 standard packet size is 127 bytes, among which IEEE 64 bit extended addresses may be used. After an association, 16 bits are used as an unique ID in a PAN L2, Still only 102 bytes are available for payload at MAC layer. Now considering the devices need to communicate with other nodes via IPv6 domain, 256 bits of the source and destination addresses seem to be cumbersome in a limited MAC payload fields. Here we propose an IP address translation mechanism. When a device in IEEE802.15.4 domain needs to communicate with other nodes in IPv6 domain, it acquires its source ID and destination ID for source IP address and destination IP address, respectively from an IP translation-capable gateway. The device will send the packet using those ID's to the gateway, and then the gateway will translate it to normal IPv6 packet. This paper will show the detailed procedures and its performance.},
	language = {eng},
	publisher = {IEEE},
	author = {{Dae-In Choi} and {Jong-tak Park} and {Su-yoen Kim} and Kahng, Hyun K.},
	year = {2011},
	note = {ISSN: 1550-445X},
	keywords = {Wireless communication ; 802.15.4 ; Logic gates ; translation ; Routing ; Global Connectivity ; 6LoWPAN ; Internet ; IP networks ; Servers ; Payloads},
	pages = {384--387},
}

@misc{noauthor_zotero_nodate,
	title = {Zotero {\textbar} {Your} personal research assistant},
	url = {https://www.zotero.org/start},
	urldate = {2021-03-02},
}

@misc{noauthor_floating_nodate,
	title = {floating point - {Why} does a float variable stop incrementing at 16777216 in {C}\#?},
	url = {https://stackoverflow.com/questions/12596695/why-does-a-float-variable-stop-incrementing-at-16777216-in-c},
	urldate = {2020-05-12},
	journal = {Stack Overflow},
	note = {Library Catalog: stackoverflow.com},
}

@misc{griffin_johncgriffinoverflow_2020,
	title = {{JohnCGriffin}/overflow},
	url = {https://github.com/JohnCGriffin/overflow},
	abstract = {Check for int/int64/int32 arithmetic overflow in Golang},
	urldate = {2020-05-11},
	author = {Griffin, John},
	month = mar,
	year = {2020},
	note = {original-date: 2017-06-10T15:33:54Z},
	keywords = {golang, overflow},
}

@misc{noauthor_go_nodate,
	title = {The {Go} {Programming} {Language} {Specification} - {The} {Go} {Programming} {Language}},
	url = {https://golang.org/ref/spec},
	urldate = {2020-05-11},
}

@article{noauthor_ieee_1985,
	title = {{IEEE} {Standard} for {Binary} {Floating}-{Point} {Arithmetic}},
	doi = {10.1109/IEEESTD.1985.82928},
	abstract = {A family of commercially feasible ways for new systems to perform binary floating-point arithmetic is defined. This standard specifies basic and extended floating-point number formats; add, subtract, multiply, divide, square root, remainder, and compare operations; conversions between integer and floating-point formats; conversions between different floating-point formats; conversions between basic-format floating-point numbers and decimal strings; and floating-point exceptions and their handling, including nonnumbers.},
	journal = {ANSI/IEEE Std 754-1985},
	month = oct,
	year = {1985},
	note = {Conference Name: ANSI/IEEE Std 754-1985},
	keywords = {Digital arithmetic, Floating-Point Working Group, Floating-point arithmetic, IEEE Computer Society, IEEE standard, Microprocessor Standards Subcommittee, Standards, Standards Committee, binary, binary floating point arithmetic, digital arithmetic, standards},
	pages = {1--20},
}

@misc{noauthor_builtin_nodate,
	title = {builtin - {The} {Go} {Programming} {Language}},
	url = {https://golang.org/pkg/builtin/},
	urldate = {2020-05-10},
}

@misc{noauthor_go_nodate-1,
	title = {The {Go} {Programming} {Language} {Specification} - {The} {Go} {Programming} {Language}},
	url = {https://golang.org/ref/spec},
	urldate = {2020-05-10},
}

@misc{noauthor_weak_nodate,
	title = {Weak {Diffie}-{Hellman} and the {Logjam} {Attack}},
	url = {https://weakdh.org/},
	urldate = {2020-04-29},
}

@misc{noauthor_sweet32_nodate,
	title = {Sweet32: {Birthday} attacks on 64-bit block ciphers in {TLS} and {OpenVPN}},
	url = {https://sweet32.info/},
	urldate = {2020-04-29},
}

@misc{noauthor_openpgp_nodate,
	title = {{OpenPGP}},
	url = {https://www.openpgp.org/},
	abstract = {Email encryption. For all operating systems. Standing the test of time.},
	language = {en},
	urldate = {2020-03-12},
	journal = {OpenPGP},
	note = {Library Catalog: www.openpgp.org},
}

@misc{noauthor_git_nodate,
	title = {Git},
	url = {https://git-scm.com/},
	urldate = {2020-03-12},
}

@misc{stevens_cr-marcstevenssha1collisiondetection_2020,
	title = {cr-marcstevens/sha1collisiondetection},
	url = {https://github.com/cr-marcstevens/sha1collisiondetection},
	abstract = {Library and command line tool to detect SHA-1 collision in a file},
	urldate = {2020-03-10},
	author = {Stevens, Marc},
	month = mar,
	year = {2020},
	note = {original-date: 2017-01-17T20:02:49Z},
}

@misc{noauthor_new_nodate,
	title = {New {SHA}-1 {Attack} - {Schneier} on {Security}},
	url = {https://www.schneier.com/blog/archives/2020/01/new_sha-1_attac.html},
	urldate = {2020-03-10},
}

@misc{noauthor_sha-1_2017,
	title = {{SHA}-1 collision detection on {GitHub}.com},
	url = {https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/},
	abstract = {A few weeks ago, researchers announced SHAttered, the first collision of the SHA-1 hash function. Starting today, all SHA-1 computations on GitHub.com will detect and reject any Git content that shows evidence of being part},
	language = {en-US},
	urldate = {2020-03-10},
	journal = {The GitHub Blog},
	month = mar,
	year = {2017},
	note = {Library Catalog: github.blog
Section: Engineering},
}

@book{stallings_cryptography_2017,
	address = {Boston},
	edition = {Seventh edition.},
	title = {Cryptography and network security: principles and practice},
	isbn = {978-0-13-444428-4},
	shorttitle = {Cryptography and network security},
	abstract = {Includes bibliographical references (pages 726-734) and index.},
	language = {eng},
	publisher = {Pearson},
	author = {Stallings, William},
	year = {2017},
	keywords = {Computer networks, Security measures; Data encryption (Computer science); Coding theory; Computer security},
}

@techreport{kelsey_second_2004,
	title = {Second {Preimages} on n-bit {Hash} {Functions} for {Much} {Less} than 2{\textasciicircum}n {Work}},
	url = {https://eprint.iacr.org/2004/304},
	abstract = {We provide a second preimage attack on all-bit iterated hash functions with Damgard-Merkle strengthening and-bit itermediate states, allowing a second preimage to be found for a-message-block message with about

work. Using SHA1 as an example, our attack can find a second preimage for abyte message inwork, rather than the previously expectedwork. We also provide slightly cheaper ways to find multicollisions than the method of Joux. Both of these results are based on expandable messages--patterns for producing messages of varying length, which all collide on the intermediate hash result immediately after processing the message. We also provide algorithms for finding expandable messages for a hash function, using only a small multiple of the work done to find a single collision in the hash function.},
	number = {304},
	urldate = {2020-03-10},
	author = {Kelsey, John and Schneier, Bruce},
	year = {2004},
	keywords = {hash functions, secret-key cryptography},
}

@misc{noauthor_collision_2020,
	title = {Collision attack},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Collision_attack&oldid=939170768},
	abstract = {In cryptography, a collision attack on a cryptographic hash tries to find two inputs producing the same hash value, i.e. a hash collision. This is in contrast to a preimage attack where a specific target hash value is specified.
There are roughly two types of collision attacks:

Collision attack
Find two different messages m1 and m2 such that hash(m1) = hash(m2).More generally:

Chosen-prefix collision attack
Given two different prefixes p1 and p2, find two appendages m1 and m2 such that hash(p1 ∥ m1) = hash(p2 ∥ m2), where ∥ denotes the concatenation operation.},
	language = {en},
	urldate = {2020-03-09},
	journal = {Wikipedia},
	month = feb,
	year = {2020},
	note = {Page Version ID: 939170768},
}

@misc{noauthor_researchers_2020,
	title = {Researchers demonstrate practical break of {SHA}-1 hash function},
	url = {https://portswigger.net/daily-swig/researchers-demonstrate-practical-break-of-sha-1-hash-function},
	abstract = {Another nail in the coffin for aging hashing algorithm},
	language = {en},
	urldate = {2020-03-08},
	journal = {The Daily Swig {\textbar} Cybersecurity news and views},
	month = jan,
	year = {2020},
	note = {Library Catalog: portswigger.net},
}

@misc{brandom_google_2017,
	title = {Google just cracked one of the building blocks of web encryption (but don’t worry)},
	url = {https://www.theverge.com/2017/2/23/14712118/google-sha1-collision-broken-web-encryption-shattered},
	abstract = {Let’s start from the beginning...},
	language = {en},
	urldate = {2020-03-08},
	journal = {The Verge},
	author = {Brandom, Russell},
	month = feb,
	year = {2017},
	note = {Library Catalog: www.theverge.com},
}

@incollection{canetti_counter-cryptanalysis_2013,
	address = {Berlin, Heidelberg},
	title = {Counter-{Cryptanalysis}},
	volume = {8042},
	isbn = {978-3-642-40040-7 978-3-642-40041-4},
	url = {http://link.springer.com/10.1007/978-3-642-40041-4_8},
	abstract = {We introduce counter-cryptanalysis as a new paradigm for strengthening weak cryptographic primitives against cryptanalytic attacks. Redesigning a weak primitive to more strongly resist cryptanalytic techniques will unavoidably break backwards compatibility. Instead, countercryptanalysis exploits unavoidable anomalies introduced by cryptanalytic attacks to detect and block cryptanalytic attacks while maintaining full backwards compatibility. Counter-cryptanalysis in principle enables the continued secure use of weak cryptographic primitives.},
	language = {en},
	urldate = {2020-02-07},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2013},
	publisher = {Springer Berlin Heidelberg},
	author = {Stevens, Marc},
	editor = {Canetti, Ran and Garay, Juan A.},
	year = {2013},
	doi = {10.1007/978-3-642-40041-4_8},
	pages = {129--146},
}

@incollection{ishai_collisions_2019,
	address = {Cham},
	title = {From {Collisions} to {Chosen}-{Prefix} {Collisions} {Application} to {Full} {SHA}-1},
	volume = {11478},
	isbn = {978-3-030-17658-7 978-3-030-17659-4},
	url = {http://link.springer.com/10.1007/978-3-030-17659-4_18},
	abstract = {A chosen-preﬁx collision attack is a stronger variant of a collision attack, where an arbitrary pair of challenge preﬁxes are turned into a collision. Chosen-preﬁx collisions are usually signiﬁcantly harder to produce than (identical-preﬁx) collisions, but the practical impact of such an attack is much larger. While many cryptographic constructions rely on collision-resistance for their security proofs, collision attacks are hard to turn into a break of concrete protocols, because the adversary has limited control over the colliding messages. On the other hand, chosenpreﬁx collisions have been shown to threaten certiﬁcates (by creating a rogue CA) and many internet protocols (TLS, SSH, IKE).},
	language = {en},
	urldate = {2020-02-02},
	booktitle = {Advances in {Cryptology} – {EUROCRYPT} 2019},
	publisher = {Springer International Publishing},
	author = {Leurent, Gaëtan and Peyrin, Thomas},
	editor = {Ishai, Yuval and Rijmen, Vincent},
	year = {2019},
	doi = {10.1007/978-3-030-17659-4_18},
	pages = {527--555},
}

@incollection{katz_first_2017,
	address = {Cham},
	title = {The {First} {Collision} for {Full} {SHA}-1},
	volume = {10401},
	isbn = {978-3-319-63687-0 978-3-319-63688-7},
	url = {http://link.springer.com/10.1007/978-3-319-63688-7_19},
	abstract = {SHA-1 is a widely used 1995 NIST cryptographic hash function standard that was oﬃcially deprecated by NIST in 2011 due to fundamental security weaknesses demonstrated in various analyses and theoretical attacks.},
	language = {en},
	urldate = {2020-02-01},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2017},
	publisher = {Springer International Publishing},
	author = {Stevens, Marc and Bursztein, Elie and Karpman, Pierre and Albertini, Ange and Markov, Yarik},
	editor = {Katz, Jonathan and Shacham, Hovav},
	year = {2017},
	doi = {10.1007/978-3-319-63688-7_19},
	pages = {570--596},
}

@misc{noauthor_google_2015,
	title = {Google will drop {SHA}-1 encryption from {Chrome} by {January} 1, 2017},
	url = {https://venturebeat.com/2015/12/18/google-will-drop-sha-1-encryption-from-chrome-by-january-1-2017/},
	abstract = {Back in September 2014, Google outlined its plans to drop support for the SHA-1 cryptographic hash algorithm in Chrome. The schedule has moved around a bit since, and now the company is committing to ditching the outdated encryption technology by January 1, 2017. Browsers and websites encrypt traffic to protect the contents of online communications …},
	language = {en-US},
	urldate = {2020-02-01},
	journal = {VentureBeat},
	month = dec,
	year = {2015},
}

@misc{noauthor_end_nodate,
	title = {The end of {SHA}-1 on the {Public} {Web}},
	url = {https://blog.mozilla.org/security/2017/02/23/the-end-of-sha-1-on-the-public-web/},
	abstract = {Our deprecation plan for the SHA-1 algorithm in the public Web, first announced in 2015, is drawing to a close. Today a team of researchers ...},
	language = {en-US},
	urldate = {2020-02-01},
	journal = {Mozilla Security Blog},
}

@techreport{barker_transitions_2015,
	title = {Transitions: {Recommendation} for {Transitioning} the {Use} of {Cryptographic} {Algorithms} and {Key} {Lengths}},
	shorttitle = {Transitions},
	url = {https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf},
	abstract = {At the start of the 21st century, the National Institute of Standards and Technology (NIST) began the task of providing cryptographic key management guidance, which includes defining and implementing appropriate key management procedures, using algorithms that adequately protect sensitive information, and planning ahead for possible changes in the use of cryptography because of algorithm breaks or the availability of more powerful computing techniques. NIST Special Publication (SP) 800-57, Part 1 was the first document produced in this effort, and includes a general approach for transitioning from one algorithm or key length to another. This Recommendation (SP 800-131A) provides more specific guidance for transitions to the use of stronger cryptographic keys and more robust algorithms.},
	language = {en},
	number = {NIST SP 800-131Ar1},
	urldate = {2020-02-01},
	institution = {National Institute of Standards and Technology},
	author = {Barker, Elaine B. and Roginsky, Allen L.},
	month = nov,
	year = {2015},
	doi = {10.6028/NIST.SP.800-131Ar1},
	pages = {NIST SP 800--131Ar1},
}

@techreport{barker_transitions_2011,
	title = {Transitions: {Recommendation} for {Transitioning} the {Use} of {Cryptographic} {Algorithms} and {Key} {Lengths}},
	shorttitle = {Transitions},
	url = {https://csrc.nist.gov/publications/detail/sp/800-131a/archive/2011-01-13},
	abstract = {At the start of the 21st century, the National Institute of Standards and Technology (NIST) began the task of providing cryptographic key management guidance, which includes defining and implementing appropriate key management procedures, using algorithms that adequately protect sensitive information, and planning ahead for possible changes in the use of cryptography because of algorithm breaks or the availability of more powerful computing techniques. NIST Special Publication (SP) 800-57, Part 1 was the first document produced in this effort, and includes a general approach for transitioning from one algorithm or key length to another. This Recommendation (SP 800-131A) provides more specific guidance for transitions to the use of stronger cryptographic keys and more robust algorithms.},
	language = {en},
	number = {NIST Special Publication (SP) 800-131A (Withdrawn)},
	urldate = {2020-02-01},
	institution = {National Institute of Standards and Technology},
	author = {Barker, Elaine and Roginsky, Allen},
	month = jan,
	year = {2011},
	doi = {https://doi.org/10.6028/NIST.SP.800-131A},
}

@techreport{dang_secure_2015,
	title = {Secure {Hash} {Standard}},
	url = {https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf},
	language = {en},
	number = {NIST FIPS 180-4},
	urldate = {2020-02-01},
	institution = {National Institute of Standards and Technology},
	author = {Dang, Quynh H.},
	month = jul,
	year = {2015},
	doi = {10.6028/NIST.FIPS.180-4},
	pages = {NIST FIPS 180--4},
}

@techreport{leurent_sha-1_2020,
	title = {{SHA}-1 is a {Shambles} - {First} {Chosen}-{Prefix} {Collision} on {SHA}-1 and {Application} to the {PGP} {Web} of {Trust}},
	url = {https://eprint.iacr.org/2020/014},
	abstract = {The SHA-1 hash function was designed in 1995 and has been widely used during two decades. A theoretical collision attack was first proposed in 2004 [WYY05], but due to its high complexity it was only implemented in practice in 2017, using a large GPU cluster [SBK+17]. More recently, an almost practical chosen-prefix collision attack against SHA-1 has been proposed [LP19]. This more powerful attack allows to build colliding messages with two arbitrary prefixes, which is much more threatening for real protocols.

Therefore, the same attacks that have been practical on MD5 since 2009 are now practical on SHA-1. In particular, chosen-prefix collisions can break signature schemes and handshake security in secure channel protocols (TLS, SSH). We strongly advise to remove SHA-1 from those type of applications as soon as possible. We exemplify our cryptanalysis by creating a pair of PGP/GnuPG keys with different identities, but colliding SHA-1 certificates. A SHA-1 certification of the first key can therefore be transferred to the second key, leading to a forgery. This proves that SHA-1 signatures now offers virtually no security in practice. The legacy branch of GnuPG still uses SHA-1 by default for identity certifications, but after notifying the authors, the modern branch now rejects SHA-1 signatures (the issue is tracked as CVE-2019-14855).},
	number = {014},
	urldate = {2020-01-13},
	author = {Leurent, Gaëtan and Peyrin, Thomas},
	year = {2020},
	keywords = {Chosen-prefix collision, Cryptanalysis, GPU, GnuPG, HPC, PGP, SHA-1, secret-key cryptography},
}

@article{leurent_first_2020,
	title = {First {Chosen}-{Preﬁx} {Collision} on {SHA}-1 and {Application} to the {PGP} {Web} of {Trust}},
	abstract = {The SHA-1 hash function was designed in 1995 and has been widely used during two decades. A theoretical collision attack was ﬁrst proposed in 2004 [WYY05], but due to its high complexity it was only implemented in practice in 2017, using a large GPU cluster [SBK+17]. More recently, an almost practical chosen-preﬁx collision attack against SHA-1 has been proposed [LP19]. This more powerful attack allows to build colliding messages with two arbitrary preﬁxes, which is much more threatening for real protocols.},
	language = {en},
	journal = {Cryptology ePrint Archive},
	author = {Leurent, Gaëtan and Peyrin, Thomas},
	month = jan,
	year = {2020},
	pages = {32},
}

@inproceedings{stevens_first_2017,
	title = {The first collision for full {SHA}-1},
	volume = {10401},
	isbn = {978-3-319-63687-0},
	doi = {10.1007/978-3-319-63688-7_19},
	abstract = {SHA-1 is a widely used 1995 NIST cryptographic hash function standard that was officially deprecated by NIST in 2011 due to fundamental security weaknesses demonstrated in various analyses and theoretical attacks. Despite its deprecation, SHA-1 remains widely used in 2017 for document and TLS certificate signatures, and also in many software such as the GIT versioning system for integrity and backup purposes. A key reason behind the reluctance of many industry players to replace SHA-1 with a safer alternative is the fact that finding an actual collision has seemed to be impractical for the past eleven years due to the high complexity and computational cost of the attack. In this paper, we demonstrate that SHA-1 collision attacks have finally become practical by providing the first known instance of a collision. Furthermore, the prefix of the colliding messages was carefully chosen so that they allow an attacker to forge two distinct PDF documents with the same SHA-1 hash that display different arbitrarily-chosen visual contents. We were able to find this collision by combining many special cryptanalytic techniques in complex ways and improving upon previous work. In total the computational effort spent is equivalent to 263.1 calls to SHA-1's compression function, and took approximately 6 500 CPU years and 100 GPU years. While the computational power spent on this collision is larger than other public cryptanalytic computations, it is still more than 100 000 times faster than a brute force search.},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	publisher = {Springer Verlag},
	author = {Stevens, M. and Bursztein, E. and Karpman, P. and Albertini, A. and Markov, Y.},
	year = {2017},
	keywords = {Collision Attack ; Collision Example ; Cryptanalysis ; Differential Path Construction ; Hash Function},
	pages = {570--596},
}

@misc{noauthor_magicpoint_nodate,
	title = {{MagicPoint} presentation foils},
	url = {http://www.openbsd.org/papers/ven05-deraadt/index.html},
	urldate = {2019-12-10},
}

@inproceedings{weidler_return-oriented_2017,
	title = {Return-{Oriented} {Programming} on a {Cortex}-{M} {Processor}},
	doi = {10.1109/Trustcom/BigDataSE/ICESS.2017.318},
	abstract = {Microcontrollers are found in many everyday devices and will only become more prevalent as the Internet of Things (IoT) gains momentum. As such, it is increasingly important that they are reasonably secure from known vulnerabilities. If we do not improve the security posture of these devices, then attackers will find ways to exploit vulnerabilities for their own gain. Due to the security protections in modern systems which prevent execution of injected shellcode, Return Oriented Programming (ROP) has emerged as a more reliable way to execute malicious code following such attacks. ROP is a method used to take over the execution of a program by causing the return address of a function to be modified through an exploit vector, then returning to small segments of otherwise innocuous code located in executable memory one after the other to carry out the attacker's aims. It will be shown that the Tiva TM4C123GH6PM microcontroller, which utilizes a Cortex-M4F processor, can be fully controlled with this technique. Sufficient code is pre-loaded into a ROM on Tiva microcontrollers to erase and rewrite the flash memory where the program resides. Then, that same ROM is searched for a Turing-complete gadget set which would allow for arbitrary execution. This would allow an attacker to re-purpose the microcontroller, altering the original functionality to his own malicious end.},
	booktitle = {2017 {IEEE} {Trustcom}/{BigDataSE}/{ICESS}},
	author = {Weidler, Nathanael R. and Brown, Dane and Mitchel, Samuel A. and Anderson, Joel and Williams, Jonathan R. and Costley, Austin and Kunz, Chase and Wilkinson, Christopher and Wehbe, Remy and Gerdes, Ryan},
	month = aug,
	year = {2017},
	note = {ISSN: 2324-9013},
	keywords = {ARM, Cortex-M4F processor, Instruction sets, Internet of Things, IoT, Microcontrollers, Programming, ROP, Radiation detectors, Read only memory, Registers, Return-oriented programming, Thumb, Tiva, Tiva TM4C123GH6PM microcontroller, Turing machines, Turing-complete gadget set, cortex-m processor, embedded, executable memory, exploit vector, flash memory, gadgets, injected shellcode, innocuous code, malicious code execution, microcontroller, microcontrollers, program execution, return-oriented programming, security of data, security posture, vectors},
	pages = {823--832},
}

@inproceedings{lee_hacking_2017,
	address = {Berkeley, CA, USA},
	series = {{SEC}'17},
	title = {Hacking in {Darkness}: {Return}-oriented {Programming} {Against} {Secure} {Enclaves}},
	isbn = {978-1-931971-40-9},
	shorttitle = {Hacking in {Darkness}},
	url = {http://dl.acm.org/citation.cfm?id=3241189.3241231},
	abstract = {Intel Software Guard Extensions (SGX) is a hardware-based Trusted Execution Environment (TEE) that is widely seen as a promising solution to traditional security threats. While SGX promises strong protection to bugfree software, decades of experience show that we have to expect vulnerabilities in any non-trivial application. In a traditional environment, such vulnerabilities often allow attackers to take complete control of vulnerable systems. Efforts to evaluate the security of SGX have focused on side-channels. So far, neither a practical attack against a vulnerability in enclave code nor a proof-of-concept attack scenario has been demonstrated. Thus, a fundamental question remains: What are the consequences and dangers of having a memory corruption vulnerability in enclave code? To answer this question, we comprehensively analyze exploitation techniques against vulnerabilities inside enclaves. We demonstrate a practical exploitation technique, called Dark-ROP, which can completely disarm the security guarantees of SGX. Dark-ROP exploits a memory corruption vulnerability in the enclave software through return-oriented programming (ROP). However Dark-ROP differs significantly from traditional ROP attacks because the target code runs under solid hardware protection. We overcome the problem of exploiting SGX-specific properties and obstacles by formulating a novel ROP attack scheme against SGX under practical assumptions. Specifically, we build several oracles that inform the attacker about the status of enclave execution. This enables him to launch the ROP attack while both code and data are hidden. In addition, we exfiltrate the enclave's code and data into a shadow application to fully control the execution environment. This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave's SGX crypto keys.},
	urldate = {2019-12-09},
	booktitle = {Proceedings of the 26th {USENIX} {Conference} on {Security} {Symposium}},
	publisher = {USENIX Association},
	author = {Lee, Jaehyuk and Jang, Jinsoo and Jang, Yeongjin and Kwak, Nohyun and Choi, Yeseul and Choi, Changho and Kim, Taesoo and Peinado, Marcus and Kang, Brent Byunghoon},
	year = {2017},
	note = {event-place: Vancouver, BC, Canada},
	pages = {523--539},
}

@inproceedings{davi_stitching_2014,
	title = {Stitching the {Gadgets}: {On} the {Ineffectiveness} of {Coarse}-{Grained} {Control}-{Flow} {Integrity} {Protection}},
	isbn = {978-1-931971-15-7},
	shorttitle = {Stitching the {Gadgets}},
	url = {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/davi},
	language = {en},
	urldate = {2019-12-08},
	author = {Davi, Lucas and Sadeghi, Ahmad-Reza and Lehmann, Daniel and Monrose, Fabian},
	year = {2014},
	pages = {401--416},
}

@inproceedings{goktas_out_2014,
	title = {Out of {Control}: {Overcoming} {Control}-{Flow} {Integrity}},
	shorttitle = {Out of {Control}},
	url = {https://ieeexplore.ieee.org/document/6956588},
	doi = {10.1109/SP.2014.43},
	abstract = {As existing defenses like ASLR, DEP, and stack cookies are not sufficient to stop determined attackers from exploiting our software, interest in Control Flow Integrity (CFI) is growing. In its ideal form, CFI prevents flows of control that were not intended by the original program, effectively putting a stop to exploitation based on return oriented programming (and many other attacks besides). Two main problems have prevented CFI from being deployed in practice. First, many CFI implementations require source code or debug information that is typically not available for commercial software. Second, in its ideal form, the technique is very expensive. It is for this reason that current research efforts focus on making CFI fast and practical. Specifically, much of the work on practical CFI is applicable to binaries, and improves performance by enforcing a looser notion of control flow integrity. In this paper, we examine the security implications of such looser notions of CFI: are they still able to prevent code reuse attacks, and if not, how hard is it to bypass its protection? Specifically, we show that with two new types of gadgets, return oriented programming is still possible. We assess the availability of our gadget sets, and demonstrate the practicality of these results with a practical exploit against Internet Explorer that bypasses modern CFI implementations.},
	language = {eng},
	urldate = {2019-12-08},
	publisher = {IEEE},
	author = {Goktas, Enes and Athanasopoulos, Elias and Bos, Herbert and Portokalidis, Georgios},
	year = {2014},
	keywords = {Software ; Security ; Internet ; Programming ; Electronic Mail ; Payloads ; Integrated Circuits ; Control-Flow Integrity Evaluation ; Code-Reuse Attack ; Computer Science, defense},
	pages = {575--589},
}

@inproceedings{hund_practical_2013,
	title = {Practical {Timing} {Side} {Channel} {Attacks} against {Kernel} {Space} {ASLR}},
	isbn = {978-1-4673-6166-8},
	url = {https://ieeexplore.ieee.org/document/6547110},
	doi = {10.1109/SP.2013.23},
	abstract = {Due to the prevalence of control-flow hijacking attacks, a wide variety of defense methods to protect both user space and kernel space code have been developed in the past years. A few examples that have received widespread adoption include stack canaries, non-executable memory, and Address Space Layout Randomization (ASLR). When implemented correctly (i.e., a given system fully supports these protection methods and no information leak exists), the attack surface is significantly reduced and typical exploitation strategies are severely thwarted. All modern desktop and server operating systems support these techniques and ASLR has also been added to different mobile operating systems recently. In this paper, we study the limitations of kernel space ASLR against a local attacker with restricted privileges. We show that an adversary can implement a generic side channel attack against the memory management system to deduce information about the privileged address space layout. Our approach is based on the intrinsic property that the different caches are shared resources on computer systems. We introduce three implementations of our methodology and show that our attacks are feasible on four different x86-based CPUs (both 32- and 64-bit architectures) and also applicable to virtual machines. As a result, we can successfully circumvent kernel space ASLR on current operating systems. Furthermore, we also discuss mitigation strategies against our attacks, and propose and implement a defense solution with negligible performance overhead.},
	language = {eng},
	urldate = {2019-12-08},
	publisher = {IEEE},
	author = {Hund, R. and Willems, C. and Holz, T.},
	year = {2013},
	keywords = {Kernel ; Aerospace Electronics ; Layout ; Timing ; Memory Management ; Linux ; Address Space Layout Randomization ; Timing Attacks ; Kernel Vulnerabilities ; Exploit Mitigation ; Computer Science, defense},
	pages = {191--205},
}

@misc{msdn_control_2018,
	title = {Control {Flow} {Guard} - {Win32} apps},
	url = {https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard},
	language = {en-us},
	urldate = {2019-12-08},
	author = {MSDN, Microsoft},
	month = may,
	year = {2018},
}

@inproceedings{kuznetsov_code-pointer_2014,
	address = {Berkeley, CA, USA},
	series = {{OSDI}'14},
	title = {Code-pointer {Integrity}},
	isbn = {978-1-931971-16-4},
	url = {http://dl.acm.org/citation.cfm?id=2685048.2685061},
	abstract = {Systems code is often written in low-level languages like C/C++, which offer many benefits but also delegate memory management to programmers. This invites memory safety bugs that attackers can exploit to divert control flow and compromise the system. Deployed defense mechanisms (e.g., ASLR, DEP) are incomplete, and stronger defense mechanisms (e.g., CFI) often have high overhead and limited guarantees [19, 15, 9]. We introduce code-pointer integrity (CPI), a new design point that guarantees the integrity of all code pointers in a program (e.g., function pointers, saved return addresses) and thereby prevents all control-flow hijack attacks, including return-oriented programming. We also introduce code-pointer separation (CPS), a relaxation of CPI with better performance properties. CPI and CPS offer substantially better security-to-overhead ratios than the state of the art, they are practical (we protect a complete FreeBSD system and over 100 packages like apache and postgresql), effective (prevent all attacks in the RIPE benchmark), and efficient: on SPEC CPU2006, CPS averages 1.2\% overhead for C and 1.9\% for C/C++, while CPI's overhead is 2.9\% for C and 8.4\% for C/C++. A prototype implementation of CPI and CPS can be obtained from http://levee.epfl.ch.},
	urldate = {2019-12-07},
	booktitle = {Proceedings of the 11th {USENIX} {Conference} on {Operating} {Systems} {Design} and {Implementation}},
	publisher = {USENIX Association},
	author = {Kuznetsov, Volodymyr and Szekeres, László and Payer, Mathias and Candea, George and Sekar, R. and Song, Dawn},
	year = {2014},
	note = {event-place: Broomfield, CO},
	keywords = {defense},
	pages = {147--163},
}

@inproceedings{borrello_rop_2019,
	title = {The {ROP} needle: {Hiding} trigger-based injection vectors via code reuse},
	volume = {147772},
	isbn = {978-1-4503-5933-7},
	shorttitle = {The {ROP} needle},
	doi = {10.1145/3297280.3297472},
	abstract = {In recent years, researchers have come up with proof of concepts of seemingly benign applications such as InstaStock and Jekyll that remain dormant until triggered by an attacker-crafted condition, which activates a malicious behavior, eluding code review and signing mechanisms. In this paper, we make a step forward by describing a stealthy injection vector design approach based on Return Oriented Programming (ROP) code reuse that provides two main novel features: 1) the ability to defer the specification of the malicious behavior until the attack is struck, allowing fine-grained targeting of the malware and reuse of the same infection vector for delivering multiple payloads over time; 2) the ability to conceal the ROP chain that specifies the malicious behavior to an analyst by using encryption. We argue that such an infection vector might be a dangerous weapon in the hands of advanced persistent threat actors. As an additional contribution, we report on a preliminary experimental investigation that seems to suggest that ROP-encoded malicious payloads are likely to pass unnoticed by current security solutions, making ROP an effective malware design ingredient.},
	publisher = {Association for Computing Machinery},
	author = {Borrello, P. and Coppa, E. and D'Elia, D. C. and Demetrescu, C.},
	year = {2019},
	keywords = {Antivirus ; Apt ; Code Reuse ; Malware ; Rop},
	pages = {1962--1970},
}

@misc{c0ntex_bypassing_2006,
	title = {Bypassing non-executable-stack during {Exploitation} (return-to-libc)},
	url = {https://www.exploit-db.com/exploits/13204},
	abstract = {Bypassing non-executable-stack during Exploitation (return-to-libc)},
	language = {en},
	urldate = {2019-12-07},
	journal = {Exploit Database},
	author = {c0ntex},
	month = apr,
	year = {2006},
}

@article{noauthor_ropocop_2016,
	title = {{ROPocop} - {Dynamic} {Mitigation} of {Code}-reuse {Attacks}},
	volume = {29},
	issn = {2214-2126},
	url = {http://dx.doi.org/10.1016/j.jisa.2016.01.002},
	doi = {10.1016/j.jisa.2016.01.002},
	abstract = {Control-flow attacks, usually achieved by exploiting a buffer-overflow vulnerability, have been a serious threat to system security for over fifteen years. Researchers have answered the threat with various mitigation techniques; but nevertheless, new exploits that successfully bypass these technologies still appear on a regular basis.In this paper, we propose ROPocop, a novel approach for detecting and preventing the execution of injected code and for mitigating code-reuse attacks such as return-oriented programming (RoP). ROPocop uses dynamic binary instrumentation, requiring neither access to source code nor debug symbols or changes to the operating system. It mitigates attacks both by monitoring the program counter at potentially dangerous points and by detecting suspicious program flows.We have implemented ROPocop for Windows x86 using PIN, a dynamic program instrumentation framework from Intel. Benchmarks using the SPEC CPU2006 suite show an average overhead of 2.4×, which is comparable to similar approaches, which give weaker guarantees. Real-world applications show only an initially noticeable input lag and no stutter. In our evaluation our tool successfully detected all 11 of the latest real-world code-reuse exploits, with no false alarms. Therefore, despite the overhead, it is a viable, temporary solution to secure critical systems against exploits if a vendor patch is not yet available.},
	number = {C},
	urldate = {2019-12-07},
	journal = {J. Inf. Secur. Appl.},
	month = aug,
	year = {2016},
	pages = {16--26},
}

@inproceedings{bletsch_mitigating_2011,
	address = {New York, NY, USA},
	series = {{ACSAC} '11},
	title = {Mitigating {Code}-reuse {Attacks} with {Control}-flow {Locking}},
	isbn = {978-1-4503-0672-0},
	url = {http://doi.acm.org/10.1145/2076732.2076783},
	doi = {10.1145/2076732.2076783},
	abstract = {Code-reuse attacks are software exploits in which an attacker directs control flow through existing code with a malicious result. One such technique, return-oriented programming, is based on "gadgets" (short pre-existing sequences of code ending in a ret instruction) being executed in arbitrary order as a result of a stack corruption exploit. Many existing codereuse defenses have relied upon a particular attribute of the attack in question (e.g., the frequency of ret instructions in a return-oriented attack), which leads to an incomplete protection, while a smaller number of efforts in protecting all exploitable control flow transfers suffer from limited deploy-ability due to high performance overhead. In this paper, we present a novel cost-effective defense technique called control flow locking, which allows for effective enforcement of control flow integrity with a small performance overhead. Specifically, instead of immediately determining whether a control flow violation happens before the control flow transfer takes place, control flow locking lazily detects the violation after the transfer. To still restrict attackers' capability, our scheme guarantees that the deviation of the normal control flow graph will only occur at most once. Further, our scheme ensures that this deviation cannot be used to craft a malicious system call, which denies any potential gains an attacker might obtain from what is permitted in the threat model. We have developed a proof-of-concept prototype in Linux and our evaluation demonstrates desirable effectiveness and competitive performance overhead with existing techniques. In several benchmarks, our scheme is able to achieve significant gains.},
	urldate = {2019-12-07},
	booktitle = {Proceedings of the 27th {Annual} {Computer} {Security} {Applications} {Conference}},
	publisher = {ACM},
	author = {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince},
	year = {2011},
	note = {event-place: Orlando, Florida, USA},
	pages = {353--362},
}

@misc{felix_fx_router_2009,
	title = {Router {Exploitation}},
	url = {https://www.recurity-labs.com/research/FX_Router_Exploitation.pdf},
	urldate = {2019-11-28},
	author = {Felix "FX", Lindner},
	year = {2009},
}

@phdthesis{kornau_return_2009,
	address = {Bochum, Germany},
	title = {return oriented programming for the {ARM} architecture},
	language = {en},
	school = {Ruhr-Universitat Bochum},
	author = {Kornau, Tim},
	year = {2009},
}

@misc{noauthor_safestack_nodate,
	title = {{SafeStack} — {Clang} 10 documentation},
	url = {https://clang.llvm.org/docs/SafeStack.html#introduction},
	urldate = {2019-12-07},
}

@misc{noauthor_can_nodate,
	title = {Can {We} {Prevent} {ROP} attacks in {LLVM}-compiled {Games}?},
	url = {http://www.justiceadams.com/blog/2019/5/28/can-we-prevent-rop-attacks-in-llvm-compiled-games},
	abstract = {Before I start, note that this will likely be my longest blog post yet. I will summarize a year's worth of research, explain the motivation behind the project, issues encountered throughout the year, and ultimately review the fruitfulness of such research. If you wish to follow along with a PowerPoi},
	language = {en-US},
	urldate = {2019-12-07},
	journal = {justiceadams.com},
}

@misc{noauthor_openbsd:_nodate,
	title = {{OpenBSD}: {Innovations}},
	url = {https://www.openbsd.org/innovations.html},
	urldate = {2019-12-07},
}

@misc{noauthor_address_2003,
	title = {Address {Space} {Layout} {Randomization} ({ASLR})},
	url = {https://pax.grsecurity.net/docs/aslr.txt},
	urldate = {2019-12-07},
	author = {, PaX Team},
	year = {2003},
}

@misc{uroz_uzetta27/easyrop_2019,
	title = {{uZetta27}/{EasyROP}},
	copyright = {GPL-3.0},
	url = {https://github.com/uZetta27/EasyROP},
	abstract = {A Python tool to generate ROP chains. Contribute to uZetta27/EasyROP development by creating an account on GitHub.},
	urldate = {2019-12-06},
	author = {Uroz, Daniel},
	month = nov,
	year = {2019},
	note = {original-date: 2016-06-02T20:35:04Z},
	keywords = {capstone, python, rop, rop-chain, rop-gadgets},
}

@misc{milanov_boyan-milanov/ropgenerator_2019,
	title = {Boyan-{MILANOV}/ropgenerator},
	copyright = {MIT},
	url = {https://github.com/Boyan-MILANOV/ropgenerator},
	abstract = {ROPGenerator is a tool that helps you building ROP exploits by finding and chaining gadgets together},
	urldate = {2019-12-06},
	author = {MILANOV, Boyan},
	month = nov,
	year = {2019},
	note = {original-date: 2018-02-10T17:55:25Z},
	keywords = {binary-exploitation, chaining-gadgets, exploit-development, gadget, rop-chain, rop-exploits, rop-gadgets, security, security-vulnerability, semantic},
}

@inproceedings{checkoway_return-oriented_2010,
	address = {New York, NY, USA},
	series = {{CCS} '10},
	title = {Return-oriented {Programming} {Without} {Returns}},
	isbn = {978-1-4503-0245-6},
	url = {http://doi.acm.org/10.1145/1866307.1866370},
	doi = {10.1145/1866307.1866370},
	abstract = {We show that on both the x86 and ARM architectures it is possible to mount return-oriented programming attacks without using return instructions. Our attacks instead make use of certain instruction sequences that behave like a return, which occur with sufficient frequency in large libraries on (x86) Linux and (ARM) Android to allow creation of Turing-complete gadget sets. Because they do not make use of return instructions, our new attacks have negative implications for several recently proposed classes of defense against return-oriented programming: those that detect the too-frequent use of returns in the instruction stream; those that detect violations of the last-in, first-out invariant normally maintained for the return-address stack; and those that modify compilers to produce code that avoids the return instruction.},
	urldate = {2019-11-28},
	booktitle = {Proceedings of the 17th {ACM} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {ACM},
	author = {Checkoway, Stephen and Davi, Lucas and Dmitrienko, Alexandra and Sadeghi, Ahmad-Reza and Shacham, Hovav and Winandy, Marcel},
	year = {2010},
	note = {event-place: Chicago, Illinois, USA},
	keywords = {arm, return-oriented programming, x86},
	pages = {559--572},
}

@inproceedings{payer_control-flow_2017,
	address = {New York, NY, USA},
	series = {{ASIA} {CCS} '17},
	title = {Control-{Flow} {Hijacking}: {Are} {We} {Making} {Progress}?},
	isbn = {978-1-4503-4944-4},
	shorttitle = {Control-{Flow} {Hijacking}},
	url = {http://doi.acm.org/10.1145/3052973.3056127},
	doi = {10.1145/3052973.3056127},
	abstract = {Memory corruption errors in C/C++ programs remain the most common source of security vulnerabilities in today's systems. Over the last 10+ years the security community developed several defenses [4]. Data Execution Prevention (DEP) protects against code injection -- eradicating this attack vector. Yet, control-flow hijacking and code reuse remain challenging despite wide deployment of Address Space Layout Randomization (ASLR) and stack canaries. These defenses are probabilistic and rely on information hiding. The deployed defenses complicate attacks, yet control-flow hijack attacks (redirecting execution to a location that would not be reached in a benign execution) are still prevalent. Attacks reuse existing gadgets (short sequences of code), often leveraging information disclosures to learn the location of the desired gadgets. Strong defense mechanisms have not yet been widely deployed due to (i) the time it takes to roll out a security mechanism, (ii) incompatibility with specific features, and (iii) performance overhead. In the meantime, only a set of low-overhead but incomplete mitigations has been deployed in practice. Control-Flow Integrity (CFI) [1,2] and Code-Pointer Integrity (CPI) [3] are two promising upcoming defense mechanisms, protecting against control-flow hijacking. CFI guarantees that the runtime control flow follows the statically determined control-flow graph. An attacker may reuse any of the valid transitions at any control-flow transfer. We compare a broad range of CFI mechanisms using a unified nomenclature based on (i) a qualitative discussion of the conceptual security guarantees, (ii) a quantitative security evaluation, and (iii){\textasciitilde}an empirical evaluation of their performance in the same test environment. For each mechanism, we evaluate (i) protected types of control-flow transfers, (ii) the precision of the protection for forward and backward edges. For open-source compiler-based implementations, we additionally evaluate (iii) the generated equivalence classes and target sets, and (iv) the runtime performance. CPI on the other hand is a dynamic property that enforces selective memory safety through bounds checks for code pointers by separating code pointers from regular data.},
	urldate = {2019-11-28},
	booktitle = {Proceedings of the 2017 {ACM} on {Asia} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {ACM},
	author = {Payer, Mathias},
	year = {2017},
	note = {event-place: Abu Dhabi, United Arab Emirates},
	keywords = {control-flow hijacking, control-flow integrity, memory safety, return-oriented programming},
	pages = {4--4},
}

@article{burow_control-flow_2017,
	title = {Control-{Flow} {Integrity}: {Precision}, {Security}, and {Performance}},
	volume = {50},
	issn = {0360-0300},
	shorttitle = {Control-{Flow} {Integrity}},
	url = {http://doi.acm.org/10.1145/3054924},
	doi = {10.1145/3054924},
	abstract = {Memory corruption errors in C/C++ programs remain the most common source of security vulnerabilities in today’s systems. Control-flow hijacking attacks exploit memory corruption vulnerabilities to divert program execution away from the intended control flow. Researchers have spent more than a decade studying and refining defenses based on Control-Flow Integrity (CFI); this technique is now integrated into several production compilers. However, so far, no study has systematically compared the various proposed CFI mechanisms nor is there any protocol on how to compare such mechanisms. We compare a broad range of CFI mechanisms using a unified nomenclature based on (i) a qualitative discussion of the conceptual security guarantees, (ii) a quantitative security evaluation, and (iii) an empirical evaluation of their performance in the same test environment. For each mechanism, we evaluate (i) protected types of control-flow transfers and (ii) precision of the protection for forward and backward edges. For open-source, compiler-based implementations, we also evaluate (iii) generated equivalence classes and target sets and (iv) runtime performance.},
	number = {1},
	urldate = {2019-11-28},
	journal = {ACM Comput. Surv.},
	author = {Burow, Nathan and Carr, Scott A. and Nash, Joseph and Larsen, Per and Franz, Michael and Brunthaler, Stefan and Payer, Mathias},
	month = apr,
	year = {2017},
	keywords = {Control-flow integrity, control-flow hijacking, return-oriented programming, shadow stack},
	pages = {16:1--16:33},
}

@inproceedings{van_der_veen_dynamics_2017,
	address = {New York, NY, USA},
	series = {{CCS} '17},
	title = {The {Dynamics} of {Innocent} {Flesh} on the {Bone}: {Code} {Reuse} {Ten} {Years} {Later}},
	isbn = {978-1-4503-4946-8},
	shorttitle = {The {Dynamics} of {Innocent} {Flesh} on the {Bone}},
	url = {http://doi.acm.org/10.1145/3133956.3134026},
	doi = {10.1145/3133956.3134026},
	abstract = {In 2007, Shacham published a seminal paper on Return-Oriented Programming (ROP), the first systematic formulation of code reuse. The paper has been highly influential, profoundly shaping the way we still think about code reuse today: an attacker analyzes the "geometry" of victim binary code to locate gadgets and chains these to craft an exploit. This model has spurred much research, with a rapid progression of increasingly sophisticated code reuse attacks and defenses over time. After ten years, the common perception is that state-of-the-art code reuse defenses are effective in significantly raising the bar and making attacks exceedingly hard. In this paper, we challenge this perception and show that an attacker going beyond "geometry" (static analysis) and considering the "dynamics" (dynamic analysis) of a victim program can easily find function call gadgets even in the presence of state-of-the-art code-reuse defenses. To support our claims, we present Newton, a run-time gadget-discovery framework based on constraint-driven dynamic taint analysis. Newton can model a broad range of defenses by mapping their properties into simple, stackable, reusable constraints, and automatically generate gadgets that comply with these constraints. Using Newton, we systematically map and compare state-of-the-art defenses, demonstrating that even simple interactions with popular server programs are adequate for finding gadgets for all state-of-the-art code-reuse defenses. We conclude with an nginx case study, which shows that a Newton-enabled attacker can craft attacks which comply with the restrictions of advanced defenses, such as CPI and context-sensitive CFI.},
	urldate = {2019-11-28},
	booktitle = {Proceedings of the 2017 {ACM} {SIGSAC} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {ACM},
	author = {van der Veen, Victor and Andriesse, Dennis and Stamatogiannakis, Manolis and Chen, Xi and Bos, Herbert and Giuffrdia, Cristiano},
	year = {2017},
	note = {event-place: Dallas, Texas, USA},
	keywords = {automatic gadget analysis, code reuse, exploitation, return-oriented programming, systematizing defenses, taint analysis},
	pages = {1675--1689},
}

@inproceedings{buchanan_when_2008,
	address = {New York, NY, USA},
	series = {{CCS} '08},
	title = {When {Good} {Instructions} {Go} {Bad}: {Generalizing} {Return}-oriented {Programming} to {RISC}},
	isbn = {978-1-59593-810-7},
	shorttitle = {When {Good} {Instructions} {Go} {Bad}},
	url = {http://doi.acm.org/10.1145/1455770.1455776},
	doi = {10.1145/1455770.1455776},
	abstract = {This paper reconsiders the threat posed by Shacham's "return-oriented programming" -- a technique by which W-xor-X-style hardware protections are evaded via carefully crafted stack frames that divert control flow into the middle of existing variable-length x86 instructions -- creating short new instructions streams that then return. We believe this attack is both more general and a greater threat than the author appreciated. In fact, the vulnerability is not limited to the x86 architecture or any particular operating system, is readily exploitable, and bypasses an entire category of malware protections. In this paper we demonstrate general return-oriented programming on the SPARC, a fixed instruction length RISC architecture with structured control flow. We construct a Turing-complete library of code gadgets using snippets of the Solaris libc, a general purpose programming language, and a compiler for constructing return-oriented exploits. Finally, we argue that the threat posed by return-oriented programming, across all architectures and systems, has negative implications for an entire class of security mechanisms: those that seek to prevent malicious computation by preventing the execution of malicious code.},
	urldate = {2019-11-02},
	booktitle = {Proceedings of the 15th {ACM} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {ACM},
	author = {Buchanan, Erik and Roemer, Ryan and Shacham, Hovav and Savage, Stefan},
	year = {2008},
	note = {event-place: Alexandria, Virginia, USA},
	keywords = {RISC, SPARC, return-into-libc, return-oriented programming},
	pages = {27--38},
}

@inproceedings{tran_expressiveness_2011,
	title = {On the expressiveness of return-into-libc attacks},
	volume = {6961},
	isbn = {978-3-642-23643-3},
	doi = {10.1007/978-3-642-23644-0_7},
	booktitle = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	author = {Tran, M. and Etheridge, M. and Bletsch, T. and Jiang, X. and Freeh, V. and Ning, P.},
	year = {2011},
	keywords = {Return-Into-Libc ; Return-Oriented Programming ; Turing-Complete, classic},
	pages = {121--141},
}

@inproceedings{shacham_geometry_2007,
	series = {{CCS} '07},
	title = {The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86)},
	isbn = {978-1-59593-703-2},
	shorttitle = {The geometry of innocent flesh on the bone},
	doi = {10.1145/1315245.1315313},
	abstract = {We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that calls no functions at all. Our attack combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to discover such instruction sequences by means of static analysis. We make use, in an essential way, of the properties of the x86 instruction set.},
	language = {eng},
	publisher = {ACM},
	author = {Shacham, Hovav},
	year = {2007},
	keywords = {Instruction Set ; Return-Into-Libc ; Turing Completeness ; Computer Science, classic},
	pages = {552--561},
}

@inproceedings{general_chair-ning_proceedings_2007,
	title = {Proceedings of the 14th {ACM} conference on {Computer} and communications security},
	isbn = {978-1-59593-703-2},
	url = {http://dl.acm.org/citation.cfm?id=1315245},
	urldate = {2019-11-02},
	publisher = {ACM},
	author = {General Chair-Ning, Peng and Program Chair-De Capitani di Vimercati, Sabrina and Program Chair-Syverson, Paul},
	month = oct,
	year = {2007},
	keywords = {classic},
}

@inproceedings{szekeres_sok:_2013,
	title = {{SoK}: {Eternal} {War} in {Memory}},
	shorttitle = {{SoK}},
	doi = {10.1109/SP.2013.13},
	abstract = {Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corruption attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other proposed protections enforcing stricter policies. We analyze the reasons why protection mechanisms implementing stricter polices are not deployed. To achieve wide adoption, protection mechanisms must support a multitude of features and must satisfy a host of requirements. Especially important is performance, as experience shows that only solutions whose overhead is in reasonable bounds get deployed. A comparison of different enforceable policies helps designers of new protection mechanisms in finding the balance between effectiveness (security) and efficiency. We identify some open research problems, and provide suggestions on improving the adoption of newer techniques.},
	booktitle = {2013 {IEEE} {Symposium} on {Security} and {Privacy}},
	author = {Szekeres, László and Payer, Mathias and Wei, Tao and Song, Dawn},
	month = may,
	year = {2013},
	note = {ISSN: 1081-6011, 1081-6011},
	keywords = {Aerospace electronics, Arrays, Computer bugs, Memory management, Programming, Safety, Security, SoK, computer security, memory corruption attacks, memory corruption bugs, program debugging, protection mechanisms, protection techniques, security of data, software reliability, storage management},
	pages = {48--62},
}

@article{volckaert_cloning_2016,
	title = {Cloning {Your} {Gadgets}: {Complete} {ROP} {Attack} {Immunity} with {Multi}-{Variant} {Execution}},
	volume = {13},
	issn = {1545-5971, 1941-0018, 2160-9209},
	shorttitle = {Cloning {Your} {Gadgets}},
	doi = {10.1109/TDSC.2015.2411254},
	abstract = {In this paper, we present disjoint code layouts (DCL), a technique that complements multi-variant execution [1] and W\$øplus\$ X protection to effectively immunize programs against control flow hijacking exploits such as return oriented programming (ROP) [2] and return-to-libc attacks [3]. DCL improves upon address space partitioning (ASP), an earlier technique presented to defeat memory exploits. Unlike ASP, our solution keeps the full virtual address space available to the protected program. Additionally, our combination of DCL with Multi-Variant Execution is transparent to both the user and the programmer and incurs much less overhead than other ROP defense tools, both in terms of run time and memory footprint.},
	number = {4},
	journal = {IEEE Transactions on Dependable and Secure Computing},
	author = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
	month = jul,
	year = {2016},
	keywords = {Computer architecture, Kernel, Layout, Linux, Monitoring, Programming, Return oriented programming, Synchronization, memory exploits, monitoring, overhead, protection, replication, return-to-libc},
	pages = {437--450},
}

@article{volckaert_cloning_2016-1,
	title = {Cloning {Your} {Gadgets}: {Complete} {ROP} {Attack} {Immunity} with {Multi}-{Variant} {Execution}},
	volume = {13},
	issn = {1545-5971},
	shorttitle = {Cloning {Your} {Gadgets}},
	doi = {10.1109/TDSC.2015.2411254},
	abstract = {In this paper, we present disjoint code layouts (DCL), a technique that complements multi-variant execution [1] and W circle plus X protection to effectively immunize programs against control flow hijacking exploits such as return oriented programming (ROP) [2] and return-to-libc attacks [3]. DCL improves upon address space partitioning (ASP), an earlier technique presented to defeat memory exploits. Unlike ASP, our solution keeps the full virtual address space available to the protected program. Additionally, our combination of DCL with Multi-Variant Execution is transparent to both the user and the programmer and incurs much less overhead than other ROP defense tools, both in terms of run time and memory footprint.},
	language = {English},
	number = {4},
	journal = {Ieee Transactions on Dependable and Secure Computing},
	author = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
	month = aug,
	year = {2016},
	note = {WOS:000384014000004},
	keywords = {Return oriented programming, memory exploits, monitoring, overhead, protection, replication, return-to-libc, software},
	pages = {437--450},
}

@article{volckaert_cloning_2016-2,
	title = {Cloning {Your} {Gadgets}: {Complete} {ROP} {Attack} {Immunity} with {Multi}-{Variant} {Execution}},
	volume = {13},
	issn = {1545-5971},
	shorttitle = {Cloning {Your} {Gadgets}},
	doi = {10.1109/TDSC.2015.2411254},
	abstract = {In this paper, we present disjoint code layouts (DCL), a technique that complements multi-variant execution [1] and W circle plus X protection to effectively immunize programs against control flow hijacking exploits such as return oriented programming (ROP) [2] and return-to-libc attacks [3]. DCL improves upon address space partitioning (ASP), an earlier technique presented to defeat memory exploits. Unlike ASP, our solution keeps the full virtual address space available to the protected program. Additionally, our combination of DCL with Multi-Variant Execution is transparent to both the user and the programmer and incurs much less overhead than other ROP defense tools, both in terms of run time and memory footprint.},
	language = {English},
	number = {4},
	journal = {Ieee Transactions on Dependable and Secure Computing},
	author = {Volckaert, Stijn and Coppens, Bart and De Sutter, Bjorn},
	month = aug,
	year = {2016},
	note = {WOS:000384014000004},
	keywords = {Return oriented programming, defense, memory exploits, monitoring, overhead, protection, replication, return-to-libc, software},
	pages = {437--450},
}

@article{weidler_return-oriented_2019,
	title = {Return-oriented programming on a resource constrained device},
	volume = {22},
	issn = {2210-5379},
	url = {http://www.sciencedirect.com/science/article/pii/S2210537917303931},
	doi = {10.1016/j.suscom.2018.10.002},
	abstract = {Microcontrollers are found in many everyday devices and will only become more prevalent as the Internet of Things (IoT) and other low power devices gain momentum. As such, it is increasingly important that they are reasonably resilient to known exploitation techniques. Modern enterprise-grade systems with virtually unlimited resources have many options when it comes to implementing state of the art intrusion prevention and detection solutions. These solutions are costly in terms of energy, execution time, circuit board area, and — of course — money. Sustainable IoT devices and power-constrained embedded systems cannot afford such costs and are forced to make suboptimal security trade-offs. One such trade-off is the design of architectures which prevent execution of injected shell code, yet have allowed Return Oriented Programming (ROP) to emerge as a more reliable way to execute malicious code following attacks. ROP is a method used to take over the execution of a program by causing the return address of a function to be modified through an exploit vector, then returning to small segments of otherwise innocuous code located in executable memory one after the other to carry out the attacker's aims. It will be shown that the Tiva TM4C123GH6PM microcontroller, which utilizes a Cortex-M4F processor, can be fully controlled with this technique. Sufficient code is pre-loaded into a ROM on Tiva microcontrollers to erase and rewrite the flash memory where the program resides. Then, that same ROM is searched for a Turing-complete gadget set which would allow for arbitrary execution. This allows an attacker to re-purpose the microcontroller, altering the original functionality to their own malicious ends. Our results show that advanced exploitation techniques are still effective against embedded systems which prioritize energy-efficiency and that more research needs to be focused on finding the right balance of security for devices with a small energy footprint.},
	language = {en},
	urldate = {2019-11-02},
	journal = {Sustainable Computing: Informatics and Systems},
	author = {Weidler, Nathanael R. and Brown, Dane and Mitchell, Samuel A. and Anderson, Joel and Williams, Jonathan R. and Costley, Austin and Kunz, Chase and Wilkinson, Christopher and Wehbe, Remy and Gerdes, Ryan},
	month = jun,
	year = {2019},
	keywords = {ARM, Flash memory, Gadgets, Microcontroller, ROP, Resource-constrained device, Return-oriented programming, Thumb},
	pages = {244--256},
}

@article{zhang_hcic:_2019,
	title = {{HCIC}: {Hardware}-{Assisted} {Control}-{Flow} {Integrity} {Checking}},
	volume = {6},
	issn = {2327-4662, 2372-2541},
	shorttitle = {{HCIC}},
	doi = {10.1109/JIOT.2018.2866164},
	abstract = {Recently, code reuse attacks (CRAs), such as return-oriented programming (ROP) and jump-oriented programming (JOP), have emerged as a new class of ingenious security threats. Attackers can utilize CRAs to hijack the control flow of programs to perform malicious actions without injecting any codes. Many defenses, classed into software-based and hardware-based, have been proposed. However, software-based methods are difficult to be deployed in practical systems due to high performance overhead. Hardware-based methods can reduce performance overhead but may require extending instruction set architectures (ISAs) and modifying the compiler or suffer the vulnerability of key leakage. To tackle these issues, this paper proposes a new hardware-assisted control flow checking method to resist CRAs with negligible performance overhead without extending ISAs, modifying the compiler or leaking the encryption/decryption key. The key technique involves two control flow checking mechanisms. The first one is the encrypted Hamming distances matching between the physical unclonable function (PUF) response and the return addresses, which prevents attackers from returning between gadgets so long as the PUF response is secret, thus resisting ROP attacks. The second one is the linear encryption/decryption operation (XOR) between the PUF response and the instructions at target addresses of call and jmp instructions to defeat JOP attacks. Advanced return-based full-function reuse attacks will be prevented with the dynamic key-updating method. Experimental evaluations on benchmarks demonstrate that the proposed method introduces negligible 0.95\% runtime overhead and 0.78\% binary size overhead on average.},
	number = {1},
	journal = {IEEE Internet of Things Journal},
	author = {Zhang, Jiliang and Qi, Binhang and Qin, Zheng and Qu, Gang},
	month = feb,
	year = {2019},
	keywords = {CRA, Code reuse attacks (CRAs), Cryptography, ISA, Internet of Things, JOP attacks, Malware, PUF response, Programming, ROP attacks, Resists, Runtime, advanced return-based full-function reuse attacks, code reuse attacks, compiler, control flow integrity (CFI), cryptography, encrypted Hamming distances, encryption-decryption key, extending instruction, hardware-assisted control flow, hardware-assisted control-flow integrity, hardware-assisted security, hardware-based methods, high performance overhead, ingenious security threats, instruction sets, jmp instructions, jump-oriented programming, key leakage, key technique, linear encryption/decryption operation, malicious actions, negligible performance overhead, physical unclonable function (PUF), physical unclonable function response, practical systems, program compilers, return addresses, return-oriented programming, software-based methods},
	pages = {458--471},
}

@inproceedings{mishra_shredder:_2018,
	address = {New York, NY, USA},
	series = {{ACSAC} '18},
	title = {Shredder: {Breaking} {Exploits} {Through} {API} {Specialization}},
	isbn = {978-1-4503-6569-7},
	shorttitle = {Shredder},
	url = {http://doi.acm.org/10.1145/3274694.3274703},
	doi = {10.1145/3274694.3274703},
	abstract = {Code reuse attacks have been a threat to software security since the introduction of non-executable memory protections. Despite significant advances in various types of additional defenses, such as control flow integrity (CFI) and leakage-resilient code randomization, recent code reuse attacks have demonstrated that these defenses are often not enough to prevent successful exploitation. Sophisticated exploits can reuse code comprising larger code fragments that conform to the enforced CFI policy and which are not affected by randomization. As a step towards improving our defenses against code reuse attacks, in this paper we present Shredder, a defense-in-depth exploit mitigation tool for the protection of closed-source applications. In a preprocessing phase, Shredder statically analyzes a given application to pinpoint the call sites of potentially useful (to attackers) system API functions, and uses backwards data flow analysis to derive their expected argument values and generate whitelisting policies in a best-effort way. At runtime, using library interposition, Shredder exposes to the protected application only specialized versions of these critical API functions, and blocks any invocation that violates the enforced policy. We have experimentally evaluated our prototype implementation for Windows programs using a large set of 251 shellcode and 30 code reuse samples, and show that it improves significantly upon code stripping, a state-of-the-art code surface reduction technique, by blocking a larger number of malicious payloads with negligible runtime overhead.},
	urldate = {2019-11-02},
	booktitle = {Proceedings of the 34th {Annual} {Computer} {Security} {Applications} {Conference}},
	publisher = {ACM},
	author = {Mishra, Shachee and Polychronakis, Michalis},
	year = {2018},
	note = {event-place: San Juan, PR, USA},
	keywords = {defense},
	pages = {1--16},
}

@book{larsen_continuing_2018,
	address = {New York, NY, USA},
	title = {The {Continuing} {Arms} {Race}: {Code}-{Reuse} {Attacks} and {Defenses}},
	isbn = {978-1-970001-83-9},
	shorttitle = {The {Continuing} {Arms} {Race}},
	abstract = {As human activities have moved to the digital domain, so have all the well-known malicious behaviors including fraud, theft, and other trickery. There is no silver bullet, and each security threat calls for a specific answer. One particular threat is that applications accept malformed inputs, and in many cases it is possible to craft inputs that let an intruder take full control over the target computer system. The nature of systems programming languages lies at the heart of the problem. Rather than rewriting decades of well-tested functionality, this book examines ways to live with the (programming) sins of the past while shoring up security in the most efficient manner possible. We explore a range of different options, each making significant progress toward securing legacy programs from malicious inputs. The solutions explored include enforcement-type defenses, which exclude certain program executions because they never arise during normal operation. Another strand explores the idea of presenting adversaries with a moving target that unpredictably changes its attack surface thanks to randomization. We also cover tandem execution ideas where the compromise of one executing clone causes it to diverge from another, thus revealing adversarial activities.},
	publisher = {Association for Computing Machinery and Morgan \& Claypool},
	editor = {Larsen, Per and Sadeghi, Ahmad-Reza},
	year = {2018},
	keywords = {attack defense},
}

@inproceedings{onarlioglu_g-free:_2010,
	address = {New York, NY, USA},
	series = {{ACSAC} '10},
	title = {G-{Free}: {Defeating} {Return}-oriented {Programming} {Through} {Gadget}-less {Binaries}},
	isbn = {978-1-4503-0133-6},
	shorttitle = {G-{Free}},
	url = {http://doi.acm.org/10.1145/1920261.1920269},
	doi = {10.1145/1920261.1920269},
	abstract = {Despite the numerous prevention and protection mechanisms that have been introduced into modern operating systems, the exploitation of memory corruption vulnerabilities still represents a serious threat to the security of software systems and networks. A recent exploitation technique, called Return-Oriented Programming (ROP), has lately attracted a considerable attention from academia. Past research on the topic has mostly focused on refining the original attack technique, or on proposing partial solutions that target only particular variants of the attack. In this paper, we present G-Free, a compiler-based approach that represents the first practical solution against any possible form of ROP. Our solution is able to eliminate all unaligned free-branch instructions inside a binary executable, and to protect the aligned free-branch instructions to prevent them from being misused by an attacker. We developed a prototype based on our approach, and evaluated it by compiling GNU libc and a number of real-world applications. The results of the experiments show that our solution is able to prevent any form of return-oriented programming.},
	urldate = {2019-11-02},
	booktitle = {Proceedings of the 26th {Annual} {Computer} {Security} {Applications} {Conference}},
	publisher = {ACM},
	author = {Onarlioglu, Kaan and Bilge, Leyla and Lanzi, Andrea and Balzarotti, Davide and Kirda, Engin},
	year = {2010},
	note = {event-place: Austin, Texas, USA},
	keywords = {ROP, defense, return-oriented programming, return-to-libc},
	pages = {49--58},
}

@inproceedings{fraser_return-oriented_2017,
	address = {New York, NY, USA},
	series = {{GECCO} '17},
	title = {Return-oriented {Programme} {Evolution} with {ROPER}: {A} {Proof} of {Concept}},
	isbn = {978-1-4503-4939-0},
	shorttitle = {Return-oriented {Programme} {Evolution} with {ROPER}},
	url = {http://doi.acm.org/10.1145/3067695.3082508},
	doi = {10.1145/3067695.3082508},
	abstract = {Return-orientated programming (ROP) identifies code snippets ending in a return instruction (gadgets) and chains them together to construct exploits. Gadgets are already present in executable memory, thus avoiding the need to explicitly inject new code. As such ROP represents one of the most difficult exploit mechanisms to mitigate. ROP design is essentially driven by the skill of human hacker, limiting the ability of exploit mitigation to reacting to attacks. In this work we describe an evolutionary approach to ROP design, thus potentially pointing to the automatic detection of vulnerabilities before application code is released.},
	urldate = {2019-11-02},
	booktitle = {Proceedings of the {Genetic} and {Evolutionary} {Computation} {Conference} {Companion}},
	publisher = {ACM},
	author = {Fraser, Olivia Lucca and Zincir-Heywood, Nur and Heywood, Malcolm and Jacobs, John T.},
	year = {2017},
	note = {event-place: Berlin, Germany},
	keywords = {ARM architecture, ROP attacks, exploit development, genetic programming},
	pages = {1447--1454},
}

@inproceedings{delia_static_2019,
	address = {New York, NY, USA},
	series = {{EuroSec} '19},
	title = {Static {Analysis} of {ROP} {Code}},
	isbn = {978-1-4503-6274-0},
	url = {http://doi.acm.org/10.1145/3301417.3312494},
	doi = {10.1145/3301417.3312494},
	abstract = {Recent years have witnessed code reuse techniques being employed to craft entire programs such as Jekyll apps, malware droppers, and persistent data-only rootkits. The increased complexity observed in such payloads calls for specific techniques and tools that can help in their analysis. In this paper we propose novel ideas for static analysis of ROP code and apply them to study prominent payloads targeting the Windows platform. Unlike state-of-the-art approaches, we do not require the ROP activation context be reproduced for the analysis. We then propose a guessing mechanism to identify gadget sources for payloads found in documents or over the network.},
	urldate = {2019-11-02},
	booktitle = {Proceedings of the 12th {European} {Workshop} on {Systems} {Security}},
	publisher = {ACM},
	author = {D'Elia, Daniele Cono and Coppa, Emilio and Salvati, Andrea and Demetrescu, Camil},
	year = {2019},
	note = {event-place: Dresden, Germany},
	keywords = {Return oriented programming, code reuse, exploits, static analysis},
	pages = {2:1--2:6},
}

@article{shrivastava_profile-guided_2019,
	title = {Profile-guided code identification and hardening using return oriented programming},
	volume = {48},
	issn = {2214-2126},
	doi = {10.1016/j.jisa.2019.102364},
	abstract = {Protecting code from a security breach needs a systematic defense. The most promising solution in this task is to protect the control flow of the code. A majority of the existing approaches for protecting the code using control flow information suffer from high performance overhead. In this paper, we propose a method for assisted discovery of profile-guided techniques for the cold-code identification and low-overhead software security hardening. Our method proceeds with identifying cold-code and hot-code by performing static and dynamic analysis on the input code. Furthermore, develops heuristics to identify security-sensitive code. The outcome of this research is the identification of a minimum number of security sensitive points with minimal overhead. This research develops a common framework for profile-guided code self-verification based on predetermined security and performance requirements. We use Return Oriented Programming (ROP) which is used mostly by adversaries for the defensive purpose to build self-verifying ROP chain. The ROP chain inserted into the code diversifies and obfuscates execution of the program hence, making it harder to breach.},
	language = {eng},
	journal = {Journal of Information Security and Applications},
	author = {Shrivastava, Rajesh Kumar and Hota, Chittaranjan},
	year = {2019},
	keywords = {Cold Code ; Hot Code ; Security Sensitive Code ; Return Oriented Programming (Rop) ; Computer Science},
}

@article{weidler_return-oriented_2019-1,
	title = {Return-oriented programming on a resource constrained device},
	volume = {22},
	issn = {2210-5379},
	doi = {10.1016/j.suscom.2018.10.002},
	abstract = {Microcontrollers are found in many everyday devices and will only become more prevalent as the Internet of Things (IoT) and other low power devices gain momentum. As such, it is increasingly important that they are reasonably resilient to known exploitation techniques. Modern enterprise-grade systems with virtually unlimited resources have many options when it comes to implementing state of the art intrusion prevention and detection solutions. These solutions are costly in terms of energy, execution time, circuit board area, and — of course — money. Sustainable IoT devices and power-constrained embedded systems cannot afford such costs and are forced to make suboptimal security trade-offs. One such trade-off is the design of architectures which prevent execution of injected shell code, yet have allowed Return Oriented Programming (ROP) to emerge as a more reliable way to execute malicious code following attacks. ROP is a method used to take over the execution of a program by causing the return address of a function to be modified through an exploit vector, then returning to small segments of otherwise innocuous code located in executable memory one after the other to carry out the attacker's aims. It will be shown that the Tiva TM4C123GH6PM microcontroller, which utilizes a Cortex-M4F processor, can be fully controlled with this technique. Sufficient code is pre-loaded into a ROM on Tiva microcontrollers to erase and rewrite the flash memory where the program resides. Then, that same ROM is searched for a Turing-complete gadget set which would allow for arbitrary execution. This allows an attacker to re-purpose the microcontroller, altering the original functionality to their own malicious ends. Our results show that advanced exploitation techniques are still effective against embedded systems which prioritize energy-efficiency and that more research needs to be focused on finding the right balance of security for devices with a small energy footprint.},
	language = {eng},
	journal = {Sustainable Computing: Informatics and Systems},
	author = {Weidler, Nathanael R. and Brown, Dane and Mitchell, Samuel A. and Anderson, Joel and Williams, Jonathan R. and Costley, Austin and Kunz, Chase and Wilkinson, Christopher and Wehbe, Remy and Gerdes, Ryan},
	year = {2019},
	keywords = {Return-Oriented Programming ; Rop ; Gadgets ; ARM ; Thumb ; Microcontroller ; Resource-Constrained Device ; Flash Memory ; Computer Science},
	pages = {244--256},
}

@article{zhang_raguard:_2019,
	title = {{RAGuard}: {An} {Efficient} and {User}-{Transparent} {Hardware} {Mechanism} against {ROP} {Attacks}},
	volume = {15},
	issn = {1544-3566},
	shorttitle = {{RAGuard}},
	doi = {10.1145/3280852},
	abstract = {Control-flow integrity (CFI) is a general method for preventing code-reuse attacks, which utilize benign code sequences to achieve arbitrary code execution. CFI ensures that the execution of a program follows the edges of its predefined static Control-Flow Graph: any deviation that constitutes a CFI violation terminates the application. Despite decades of research effort, there are still several implementation challenges in efficiently protecting the control flow of function returns (Return-Oriented Programming attacks). The set of valid return addresses of frequently called functions can be large and thus an attacker could bend the backward-edge CFI by modifying an indirect branch target to another within the valid return set. This article proposes RAGuard, an efficient and user-transparent hardware-based approach to prevent Return-Oreiented Programming attacks. RAGuard binds a message authentication code (MAC) to each return address to protect its integrity. To guarantee the security of the MAC and reduce runtime overhead: RAGuard (1) computes the MAC by encrypting the signature of a return address with AES-128, (2) develops a key management module based on a Physical Unclonable Function (PUF) and a True Random Number Generator (TRNG), and (3) uses a dedicated register to reduce MACs' load and store operations of leaf functions. We have evaluated our mechanism based on the open-source LEON3 processor and the results show that RAGuard incurs acceptable performance overhead and occupies reasonable area.},
	language = {eng},
	number = {4},
	journal = {ACM Transactions on Architecture and Code Optimization (TACO)},
	author = {Zhang, Jun and Hou, Rui and Song, Wei and Mckee, Sally and Jia, Zhen and Zheng, Chen and Chen, Mingyu and Zhang, Lixin and Meng, Dan},
	year = {2019},
	keywords = {Aes-128 ; Code-Reuse Attacks ; Puf ; Key Management ; Message Authentication Code ; Return-Oriented Programming Attacks ; Computer Science},
	pages = {1--21},
}

@article{noauthor_acm_nodate,
	title = {{ACM} {Transactions} on {Architecture} and {Code} {Optimization} ({TACO})},
	issn = {1544-3566},
	url = {http://dl.acm.org/citation.cfm?id=J924},
	urldate = {2019-10-30},
}

@article{lee_hacking_nodate,
	title = {Hacking in {Darkness}: {Return}-oriented {Programming} against {Secure} {Enclaves}},
	abstract = {Intel Software Guard Extensions (SGX) is a hardwarebased Trusted Execution Environment (TEE) that is widely seen as a promising solution to traditional security threats. While SGX promises strong protection to bugfree software, decades of experience show that we have to expect vulnerabilities in any non-trivial application. In a traditional environment, such vulnerabilities often allow attackers to take complete control of vulnerable systems. Efforts to evaluate the security of SGX have focused on side-channels. So far, neither a practical attack against a vulnerability in enclave code nor a proof-of-concept attack scenario has been demonstrated. Thus, a fundamental question remains: What are the consequences and dangers of having a memory corruption vulnerability in enclave code? To answer this question, we comprehensively analyze exploitation techniques against vulnerabilities inside enclaves. We demonstrate a practical exploitation technique, called Dark-ROP, which can completely disarm the security guarantees of SGX. Dark-ROP exploits a memory corruption vulnerability in the enclave software through return-oriented programming (ROP). However Dark-ROP differs significantly from traditional ROP attacks because the target code runs under solid hardware protection. We overcome the problem of exploiting SGX-specific properties and obstacles by formulating a novel ROP attack scheme against SGX under practical assumptions. Specifically, we build several oracles that inform the attacker about the status of enclave execution. This enables him to launch the ROP attack while both code and data are hidden. In addition, we exfiltrate the enclave’s code and data into a shadow application to fully control the execution environment. This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave’s SGX crypto keys.},
	language = {en},
	author = {Lee, Jaehyuk and Jang, Jinsoo and Jang, Yeongjin and Kwak, Nohyun and Choi, Yeseul and Choi, Changho and Kim, Taesoo and Peinado, Marcus and Kang, Brent Byunghoon},
	pages = {19},
}

@misc{noauthor_return-oriented_nodate,
	title = {Return-oriented programming on a resource constrained device {\textbar} {Elsevier} {Enhanced} {Reader}},
	url = {https://reader.elsevier.com/reader/sd/pii/S2210537917303931?token=E18B0F674C3FD72154F7F14AE90305FA602CDC54CCD5F44EA80BA264FA08FFA6936B2540D7F95A5BF23ADCCD17D0E583},
	language = {en},
	urldate = {2019-10-30},
	doi = {10.1016/j.suscom.2018.10.002},
}

@article{weidler_return-oriented_2019-2,
	title = {Return-oriented programming on a resource constrained device},
	volume = {22},
	issn = {2210-5379},
	url = {http://www.sciencedirect.com/science/article/pii/S2210537917303931},
	doi = {10.1016/j.suscom.2018.10.002},
	abstract = {Microcontrollers are found in many everyday devices and will only become more prevalent as the Internet of Things (IoT) and other low power devices gain momentum. As such, it is increasingly important that they are reasonably resilient to known exploitation techniques. Modern enterprise-grade systems with virtually unlimited resources have many options when it comes to implementing state of the art intrusion prevention and detection solutions. These solutions are costly in terms of energy, execution time, circuit board area, and — of course — money. Sustainable IoT devices and power-constrained embedded systems cannot afford such costs and are forced to make suboptimal security trade-offs. One such trade-off is the design of architectures which prevent execution of injected shell code, yet have allowed Return Oriented Programming (ROP) to emerge as a more reliable way to execute malicious code following attacks. ROP is a method used to take over the execution of a program by causing the return address of a function to be modified through an exploit vector, then returning to small segments of otherwise innocuous code located in executable memory one after the other to carry out the attacker's aims. It will be shown that the Tiva TM4C123GH6PM microcontroller, which utilizes a Cortex-M4F processor, can be fully controlled with this technique. Sufficient code is pre-loaded into a ROM on Tiva microcontrollers to erase and rewrite the flash memory where the program resides. Then, that same ROM is searched for a Turing-complete gadget set which would allow for arbitrary execution. This allows an attacker to re-purpose the microcontroller, altering the original functionality to their own malicious ends. Our results show that advanced exploitation techniques are still effective against embedded systems which prioritize energy-efficiency and that more research needs to be focused on finding the right balance of security for devices with a small energy footprint.},
	language = {en},
	urldate = {2019-10-30},
	journal = {Sustainable Computing: Informatics and Systems},
	author = {Weidler, Nathanael R. and Brown, Dane and Mitchell, Samuel A. and Anderson, Joel and Williams, Jonathan R. and Costley, Austin and Kunz, Chase and Wilkinson, Christopher and Wehbe, Remy and Gerdes, Ryan},
	month = jun,
	year = {2019},
	keywords = {ARM, Flash memory, Gadgets, Microcontroller, ROP, Resource-constrained device, Return-oriented programming, Thumb},
	pages = {244--256},
}

@misc{noauthor_return-oriented_2019,
	title = {Return-oriented programming},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Return-oriented_programming&oldid=923437446},
	abstract = {Return-oriented programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing.In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine's memory, called "gadgets". Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks.},
	language = {en},
	urldate = {2019-10-30},
	journal = {Wikipedia},
	month = oct,
	year = {2019},
	note = {Page Version ID: 923437446},
}

@misc{noauthor_openbsd_nodate,
	title = {{OpenBSD} 6.6},
	url = {https://www.openbsd.org/66.html},
	urldate = {2019-10-23},
}

@misc{noauthor_interview_nodate,
	title = {An {Interview} {With} {Former} {Purism} {CTO} {Zlatan} {Todoric} {Hints} {At} {Chaos} {At} {Purism} - {Slashdot}},
	url = {https://linux.slashdot.org/story/19/10/22/2152232/an-interview-with-former-purism-cto-zlatan-todoric-hints-at-chaos-at-purism?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+Slashdot%2FslashdotHardware+%28Slashdot%3A+Hardware%29},
	abstract = {mpol writes: Phoronix published an interview with former Purism CTO Zlatan Todoric who left Purism in September 2018. The story hints quite strongly at chaotic situations over at Purism. He started at the company in 2015, when it was a small outfit, and steered it into the bigger company that it is ...},
	language = {en},
	urldate = {2019-10-23},
}

@misc{noauthor_zotero_nodate-1,
	title = {Zotero {\textbar} {Email} validation},
	url = {https://www.zotero.org/user/validate/6221871d0db311b0e54f},
	urldate = {2019-10-22},
}
